{"markdown":"## next 简介\nnext.js作为一款轻量级的应用框架，主要用于构建静态网站和后端渲染网站。\n\n## next 特点\n\n- 默认情况下由服务器呈现\n- 自动代码拆分可加快页面加载速度\n- 简单的客户端路由（基于页面）\n- 基于 Webpack 的开发环境,支持热模块替换（HMR）\n- 能够与 Express 或任何其他 Node.js HTTP 服务器一起实现\n- 可使用您自己的 Babel 和 Webpack 配置进行自定义\n\n## 系统需求\n\nNext.js 可与 Windows,Mac 和 Linux 一起使用.您只需要在系统上安装 Node.js 即可开始构建 Next.js 应用程序.如果有个编辑器就更好了\n\n## 初始化项目\n\n```\nmkdir next-demo //创建项目\ncd next-demo //进入项目\nnpm init -y // 快速创建package.json而不用进行一些选择\nnpm install --save react react-dom next // 安装依赖\nmkdir pages //创建pages\n```\n\nmkdir pages 这一步是必须创建一个叫 pages 的文件夹,因为 next 是根据 pages 下面的 js jsx tsx 文件来进行路由生成,且文件夹名字必须是pages\n\n然后打开 package.json 目录中的 next-demo 文件并替换 scripts 为以下内容：\n\n```\n\"scripts\": {\n  \"dev\": \"next\",\n  \"build\": \"next build\",\n  \"start\": \"next start\"\n}\n```\n\n运行以下命令以启动开发服务器：\n\n```\nnpm run dev\n```\n\n现在可以打开 localhost:3000 来查看页面效果,如果不喜欢 3000 或者端口冲突,执行下面命令\n\n```\nnpm run dev -p 6688(你喜欢的端口)\n```\n\n这时候就可以在 localhost:6688 上看到页面效果了\n\n#### hello world\n\n此时我们在 pages 文件夹下创建一个 index.js 作为首页\n\n```\nconst Index = () => (\n  <div>\n    <p>Hello Next.js</p>\n  </div>\n);\n\nexport default Index;\n```\n\n再次查看 localhost:6688 就可以看到当前页面显示出 hello world\n\n## 页面间导航\n\nnext 中实现路由非常的简便,新建 pages/about.js\n\n```\nexport default function About() {\n  return (\n    <div>\n      <p>This is the about page</p>\n    </div>\n  );\n}\n```\n\n此时访问 localhost:6688/about,就可以看到页面相应的效果(路由与 pages 下的文件名称完全匹配)\n\n页面间的导航,我们可以 a 标签来进行导航.但是,它不会执行客户端导航.并且,每次点击浏览器将向服务器请求下一页,同时刷新页面.因此,为了支持客户端导航,,我们需要使用 Next.js 的 Link API,该 API 通过导出 next/link. Link 将预取页面,并且导航将在不刷新页面的情况下进行.\n\n#### 使用 Link API\n\n修改 pages/index.js\n\n```\nimport Link from 'next/link';\n\nconst Index = () => (\n  <div>\n    <Link href=\"/about\">\n      <a>About Page</a>\n    </Link>\n    <p>Hello Next.js</p>\n  </div>\n);\n\nexport default Index;\n```\n\n再次访问 localhost:6688,然后点击 About Page 跳转到 about 页面.之后点击浏览器的后退按钮,页面能够回到 index.\n\n> Link组件默认是将路由push进入浏览器记录,所以点击后退按钮是返回上一页.这一默认形式可以替换为replace,更改为`<Link href=\"/about\" replace>`\n\n因为 next/link 只是一个更高阶的组件(高阶组件) , next/link 组件上的设置 props 无效.只接受 href 和类似的 props.如果需要向其添加 props,则需要对下级组件进行添加. next/link 组件不会将那些 props 传递给子组件,并且还会给你一个错误警告.在这种情况下,next/link 组件的子组件/元素是接受样式和其他 props 最好对象.它可以是任何组件或标签,唯一要求是能够接受 onClick 事件.\n\n> 如果将功能组件作为子组件进行传递,则需要将功能组件包装`React.forwardRef`才能在`<Link>`使用\n\n\n```\n  <Link href=\"/about\">\n    <a className=\"redLink\">About Page</a>\n  </Link>\n\n  <Link href=\"/show\">\n    <div>Show Page</div>\n  </Link>\n```\n\n> 这是客户端导航；该操作在浏览器中进行,而无需向服务器发出请求.打开开发者工具 networks 进行查看\n\n另外的客户端导航是Router\n```\nimport Router from 'next/router'\n\nfunction Index() {\n  return (\n   <div>\n      Click <span onClick={() => Router.push('/about')}>here</span> to read more\n    </div>\n  )\n}\n\nexport default Index\n```\n\n[Next.js更多关于路由route的内容](https://nextjs.org/docs/#routing)\n\n> 尽管实现代码的过程中以及官方案例中在Link组件里将a标签作为子元素传进去,但是实际使用中,a标签会造成路由切换失效的情况,酌情使用其他标签代替.\n\n## 组件\n\n目前 Next.js 代码都是关于页面的.我们可以通过导出 React 组件并将该组件放入 pages 目录来创建页面.然后,它将具有基于文件名的固定 URL. 但同时一些共享组件也是项目中必须的,我们将创建一个公共的 Header 组件并将其用于多个页面.\n\n#### 创建公用组件\n\n新建 components/Header.js\n\n```\nimport Link from \"next/link\";\n\nconst linkStyle = {\n  marginRight: 15\n};\n\nconst Header = () => (\n  <div>\n    <Link href=\"/\">\n      <a style={linkStyle}>Home</a>\n    </Link>\n    <Link href=\"/about\">\n      <a style={linkStyle}>About</a>\n    </Link>\n    <Link href=\"/show\">\n      <a style={linkStyle}>Show</a>\n    </Link>\n  </div>\n);\n\nexport default Header;\n```\n\n然后修改 pages 目录下的 index.js / about.js / show.js\n\n```\nimport Header from '../components/Header';\n\nexport default function Show() {\n  return (\n    <div>\n      <Header />\n      <p>Hello Next.js</p>\n    </div>\n  );\n}\n```\n\n打开 localhost:6688 点击 3 个 link 按钮就可以进行页面间的来回跳转了\n\n> 当前所使用的components这个名字并不是必须的,你可以将这个文件夹命名为任何名称.next中固定且不能改变的文件夹只有两个'pages'和'static'.next也并不限制将公共组件存放在pages里面,但最好不要在 pages 里面创建共享组件,这样会生成许多无效的路由.\n\n#### layout 组件\n\n在我们的应用中,我们将在各个页面上使用通用样式.为此,我们可以创建一个通用的 Layout 组件并将其用于我们的每个页面.\n\ncomponents/MyLayout.js\n\n```\nimport Header from './Header';\n\nconst layoutStyle = {\n  margin: 20,\n  padding: 20,\n  border: '1px solid #DDD'\n};\n\nconst Layout = props => (\n  <div style={layoutStyle}>\n    <Header />\n    {props.children}\n  </div>\n);\n\nexport default Layout;\n```\n\n然后修改 pages 目录下的 index.js / about.js / show.js\n\n```\nimport Layout from '../components/MyLayout';\n\nexport default function Show() {\n  return (\n    <Layout>\n      <p>Hello Next.js</p>\n    </Layout>\n  );\n}\n```\n\n此外还可以使用 hoc 组件进行内容传递获取使用 props 属性进行传递.最终实现的是布局组件实现了多页面共用.\n\n## 动态页面\n\n在实际应用中,我们需要创建动态页面来显示动态内容.\n\n首先修改 pages/about.js 文件\n\n```\nimport Layout from \"../components/MyLayout\";\nimport Link from \"next/link\";\n\nconst PostLink = props => (\n  <li>\n    <Link href={`/post?title=${props.title}`}>\n      <a>{props.title}</a>\n    </Link>\n  </li>\n);\n\nexport default function About() {\n  return (\n    <Layout>\n      <h1>My Blog</h1>\n      <ul>\n        <PostLink title=\"Hello Next.js\" />\n        <PostLink title=\"Learn Next.js is awesome\" />\n        <PostLink title=\"Deploy apps with Zeit\" />\n      </ul>\n    </Layout>\n  );\n}\n```\n\n同样的效果Link使用对象形式\n```\n<Link href={{ pathname: '/post', query: { title: 'this is title' } }}>\n```\n\n依然同样的效果使用Router\n```\nimport Router from 'next/router'\n\nconst handler = () => {\n  Router.push({\n    pathname: '/about',\n    query: { name: 'this is title },\n  })\n}\n```\n\nRouter.push(url, as)与Link组件使用了相同的参数,第一个参数就是url,如果有第二参数,就是对应as\n\n创建 pages/post.js\n\n```\nimport { useRouter } from 'next/router';\nimport Layout from '../components/MyLayout';\n\nconst Page = () => {\n  const router = useRouter();\n\n  return (\n    <Layout>\n      <h1>{router.query.title}</h1>\n      <p>This is the blog post content.</p>\n    </Layout>\n  );\n};\n\nexport default Page;\n```\n\n打开 localhost:6688 查看页面效果,点击 about 下面的 3 个帖子,会出现对应的 title 页面\n\n- 我们通过查询字符串参数（查询参数）传递数据,通过查询字符串传递任何类型的数据.\n- 我们导入并使用 useRouter 函数,next/router 函数将返回 Next.js router 对象.\n- 我们使用 query 获取查询字符串参数\n- 获得标题需要的参数 router.query.title.\n\npost 页面也可以添加通用 header\n\n```\nimport { useRouter } from \"next/router\";\nimport Layout from \"../components/MyLayout\";\n\nconst Content = () => {\n  const router = useRouter();\n\n  return (\n    <Layout>\n      <h1>{router.query.title}</h1>\n      <p>This is the blog post content.</p>\n    </Layout>\n  );\n};\n\nconst Page = () => (\n  <Layout>\n    <Content />\n  </Layout>\n);\n\nexport default Page;\n```\n\n再次查看 localhost:6688 看看不同,现在的页面也具有一套完整的布局.\n\n#### 路由事件\n\n可以通过Router监听路由器内部发生的不同事件\n```\n// 监听\nRouter.events.on('routeChangeStart', handleRouteChange)\n// 关闭\nRouter.events.off('routeChangeStart', handleRouteChange)\n```\n\n- routeChangeStart(url) 当路由开始改变时触发\n- routeChangeComplete(url) 路由完全改变时触发\n- routeChangeError(err, url) 更改路由时发生错误或取消路由负载时触发\n- beforeHistoryChange(url) 在更改浏览器的历史记录之前触发\n- hashChangeStart(url) 当哈希值改变但页面不改变时触发\n- hashChangeComplete(url) 哈希值更改但页面未更改时触发\n\n> 官方表示getInitialProps情况下不建议使用路由器事件.如果需要最好是在组件加载后或者某些事件后进行监听.\n\n## 动态路由\n\n当前我们的路由是这样的 http://localhost:6688/post?title=Hello%20Next.js , 现在需要更干净的路由 http://localhost:6688/p/10. 添加新页面来创建我们的第一个动态路由 p/[id].js\n\n新建 pages/p/[id].js\n\n```\nimport { useRouter } from 'next/router';\nimport Layout from '../../components/MyLayout';\n\nexport default function Post() {\n  const router = useRouter();\n\n  return (\n    <Layout>\n      <h1>{router.query.id}</h1>\n      <p>This is the blog post content.</p>\n    </Layout>\n  );\n}\n```\n\n- next 会处理后面的路由/p/.例如,/p/hello-nextjs 将由此页面处理.而/p/post-1/another 不会.\n- 方括号使其成为动态路由.而且在匹配动态路由的时候必须使用全名,无法添加前缀或者后缀.例如,/pages/p/[id].js 受支持,但/pages/p/post-[id].js 不受支持.\n- 创建动态路由时,我们 id 放在方括号之间.这是页面接收到的查询参数的名称,因此/p/hello-nextjs 在 query 对象就是{ id: 'hello-nextjs'},我们可以使用 useRouter（）进行访问.\n\n> `useRouter`是一个React钩子函数,它不能与类一起使用.类组件可以使用`withRouter`高阶组件或将类包装在功能组件中.同时withRouter也可以直接用于功能组件中.\n\n在链接多个页面,新建 pages/page.js\n\n```\nimport Layout from '../components/MyLayout';\nimport Link from 'next/link';\n\nconst PostLink = props => (\n  <li>\n    <Link href=\"/p/[id]\" as={`/p/${props.id}`}>\n      <a>{props.id}</a>\n    </Link>\n  </li>\n);\n\nexport default function Blog() {\n  return (\n    <Layout>\n      <h1>My Blog</h1>\n      <ul>\n        <PostLink id=\"hello-nextjs\" />\n        <PostLink id=\"learn-nextjs\" />\n        <PostLink id=\"deploy-nextjs\" />\n      </ul>\n    </Layout>\n  );\n}\n```\n\n`<Link href={`/p?id=\\${item.id}`} as={`/p/${item.id}`}>`,访问路径就是http://localhost:6688/p/975\n\n`<Link href={`/p?id=\\${item.id}`}>`,访问路径就是http://localhost:6688/p?id=975\n\n` <Link href={`/p?id=\\${item.id}`} as={`/post/${item.id}`}>`,起别名http://localhost:6688/post/975\n\n\n在该页面中我们看一下<Link>元素,其中 href 属性 p 文件夹中页面的路径, as 是要在浏览器的 URL 栏中显示的 URL,这是next官方提供的一个路由遮挡功能,用来隐藏原本复杂的路由,显示出来简洁的路由.使网站路径更简洁.as 通常是用来与浏览器历史记录配合使用.\n\n## 获取远程数据\n\n实际上,我们通常需要从远程数据源获取数据.Next.js 自己有标准 API 来获取页面数据.我们通常使用异步函数 getInitialProps 来完成此操作 .这样,我们可以通过远程数据源获取数据到页面上,并将其作为 props 传递给我们的页面.getInitialProps 在服务器和客户端上均可使用.\n\n首先需要一个获取数据的库\n\n```\nnpm install --save isomorphic-unfetch\n```\n\n然后修改 pages/index.js\n\n```\nimport Layout from '../components/MyLayout';\nimport Link from 'next/link';\nimport fetch from 'isomorphic-unfetch';\n\nconst Index = props => (\n  <Layout>\n    <h1>Batman TV Shows</h1>\n    <ul>\n      {props.shows.map(show => (\n        <li key={show.id}>\n          <Link href=\"/detail/[id]\" as={`/detail/${show.id}`}>\n            <a>{show.name}</a>\n          </Link>\n        </li>\n      ))}\n    </ul>\n  </Layout>\n);\n\nIndex.getInitialProps = async function() {\n  const res = await fetch('https://api.tvmaze.com/search/shows?q=batman');\n  const data = await res.json();\n\n  return {\n    shows: data.map(entry => entry.show)\n  };\n};\n\nexport default Index;\n```\n\n现在这种情况下,我们只会在服务器上获取数据,因为我们是在服务端进行渲染.\n\n再创建一个详情页,这里用到了动态路由\n\n新建 pages/detail/[id].js\n\n```\nimport Layout from \"../../components/MyLayout\";\nimport fetch from \"isomorphic-unfetch\";\nimport Markdown from \"react-markdown\";\n\nconst Post = props => (\n  <Layout>\n    <h1>{props.show.name}</h1>\n    <div className=\"markdown\">\n      <Markdown source={props.show.summary.replace(/<[/]?p>/g, \"\")} />\n    </div>\n    <img src={props.show.image.medium} />\n    <style jsx global>{`\n     .markdown {\n        font-family: \"Arial\";\n      }\n\n     .markdown a {\n        text-decoration: none;\n        color: blue;\n      }\n\n     .markdown a:hover {\n        opacity: 0.6;\n      }\n\n     .markdown h3 {\n        margin: 0;\n        padding: 0;\n        text-transform: uppercase;\n      }\n    `}</style>\n  </Layout>\n);\n\nPost.getInitialProps = async function(context) {\n  const { id } = context.query;\n  const res = await fetch(`https://api.tvmaze.com/shows/${id}`);\n  const show = await res.json();\n\n  return { show };\n};\n\nexport default Post;\n```\n\n点击 list 中的随便一个,然后打开控制台和浏览器的 networks,会发现这次是在浏览器端进行接口请求.\n\ngetInitialProps 上下文对象context具有以下属性\n\n- pathname -URL的路径部分\n- query -URL的查询字符串部分被解析为对象\n- asPath- String实际路径（包括查询）的-在浏览器中显示\n- req -HTTP请求对象（仅服务器）\n- res -HTTP响应对象（仅服务器）\n- err -渲染期间遇到任何错误的错误对象\n\n## 给组件添加样式\n\nNext.js 在 JS 框架中预加载了一个称为 styled-jsx 的 CSS,该 CSS 使你的代码编写更轻松.它允许您为组件编写熟悉的 CSS 规则.规则对组件（甚至子组件）以外的任何东西都没有影响.简单来说就是带有作用域的 css.\n\n修改 pages/page.js\n\n```\nimport Layout from \"../components/MyLayout\";\nimport Link from \"next/link\";\n\nfunction getPosts() {\n  return [\n    { id: \"hello-nextjs\", title: \"Hello Next.js\" },\n    { id: \"learn-nextjs\", title: \"Learn Next.js is awesome\" },\n    { id: \"deploy-nextjs\", title: \"Deploy apps with ZEIT\" }\n  ];\n}\n\nexport default function Blog() {\n  return (\n    <Layout>\n      <h1>My Blog</h1>\n      <ul>\n        {getPosts().map(post => (\n          <li key={post.id}>\n            <Link href=\"/p/[id]\" as={`/p/${post.id}`}>\n              <a>{post.title}</a>\n            </Link>\n          </li>\n        ))}\n      </ul>\n      <style jsx>{`\n        h1,\n        a {\n          font-family: \"Arial\";\n        }\n\n        ul {\n          padding: 0;\n        }\n\n        li {\n          list-style: none;\n          margin: 5px 0;\n        }\n\n        a {\n          text-decoration: none;\n          color: red;\n        }\n\n        a:hover {\n          opacity: 0.6;\n        }\n      `}</style>\n    </Layout>\n  );\n}\n```\n\n在上面的代码中,我们直接写在模板字符串中,而且必须使用模板字符串（{``}）编写 CSS .\n\n此时修改一下代码\n\n```\nimport Layout from \"../components/MyLayout\";\nimport Link from \"next/link\";\n\nfunction getPosts() {\n  return [\n    { id: \"hello-nextjs\", title: \"Hello Next.js\" },\n    { id: \"learn-nextjs\", title: \"Learn Next.js is awesome\" },\n    { id: \"deploy-nextjs\", title: \"Deploy apps with ZEIT\" }\n  ];\n}\n\nconst PostLink = ({ post }) => (\n  <li>\n    <Link href=\"/p/[id]\" as={`/p/${post.id}`}>\n      <a>{post.title}</a>\n    </Link>\n  </li>\n);\n\nexport default function Blog() {\n  return (\n    <Layout>\n      <h1>My Blog</h1>\n      <ul>\n        {getPosts().map(post => (\n          <PostLink key={post.id} post={post} />\n        ))}\n      </ul>\n      <style jsx>{`\n        h1,\n        a {\n          font-family: \"Arial\";\n        }\n\n        ul {\n          padding: 0;\n        }\n\n        li {\n          list-style: none;\n          margin: 5px 0;\n        }\n\n        a {\n          text-decoration: none;\n          color: blue;\n        }\n\n        a:hover {\n          opacity: 0.6;\n        }\n      `}</style>\n    </Layout>\n  );\n}\n```\n\n这时候打开浏览器观察就会发现也是不生效,这是因为 style jsx 这种写法样式是有作用域,css 只能在当前作用域下生效.\n\n解决 1 , 给子组件添加上子组件的样式\n\n```\nconst PostLink = ({ post }) => (\n  <li>\n    <Link href=\"/p/[id]\" as={`/p/${post.id}`}>\n      <a>{post.title}</a>\n    </Link>\n    <style jsx>{`\n      li {\n        list-style: none;\n        margin: 5px 0;\n      }\n\n      a {\n        text-decoration: none;\n        color: blue;\n        font-family: 'Arial';\n      }\n\n      a:hover {\n        opacity: 0.6;\n      }\n    `}</style>\n  </li>\n);\n```\n\n解决 2 , [全局样式](https://github.com/zeit/styled-jsx#one-off-global-selectors)\n\n```\n <style jsx global>{`\n......css\n `}\n```\n\n一般不使用全局样式来解决\n\n[styled-jsx 文档](https://www.npmjs.com/package/styled-jsx)\n\n#### 使用全局样式\n\n有时,我们确实需要更改子组件内部的样式.尤其是使用一些第三方库样式又有些不满意的时候.\n\n安装 react-markdown\n\n```\nnpm install --save react-markdown\n```\n\n修改 pages/post.js\n\n```\nimport { useRouter } from \"next/router\";\nimport Layout from \"../components/MyLayout\";\nimport Markdown from \"react-markdown\";\n\nconst Content = () => {\n  const router = useRouter();\n\n  return (\n    <Layout>\n      <h1>{router.query.title}</h1>\n      <div className=\"markdown\">\n        <Markdown\n          source={`  # Live demo\n\n                  Changes are automatically rendered as you type.\n\n                  ## Table of Contents\n\n                  * Implements [GitHub Flavored Markdown](https://github.github.com/gfm/)\n                  * Renders actual, \"native\" React DOM elements\n                  * Allows you to escape or skip HTML (try toggling the checkboxes above)\n                  * If you escape or skip the HTML, no dangerouslySetInnerHTML is used! Yay!\n\n                  ## HTML block below\n\n                <blockquote>\n                  This blockquote will change based on the HTML settings above.\n                </blockquote>`\n            }\n        />\n      </div>\n      <style jsx global>{`\n       .markdown {\n          font-family: \"Arial\";\n        }\n\n       .markdown a {\n          text-decoration: none;\n          color: blue;\n        }\n\n       .markdown a:hover {\n          opacity: 0.6;\n        }\n\n       .markdown h3 {\n          margin: 0;\n          padding: 0;\n          text-transform: uppercase;\n        }\n      `}</style>\n    </Layout>\n  );\n};\n\nconst Page = () => (\n  <Layout>\n    <Content />\n  </Layout>\n);\n\nexport default Page;\n```\n\n打开 localhost:6688 的 about 页面点击查看样式效果\n\n[其他解决方案](https://github.com/zeit/next.js#css-in-js)\n\n## 引入 ui 库\n\n目前代码在页面中呈现的样式是比较随意的,秉承着能打开就行的原则开发到这一步,是否应该稍微美化一下下.\n\n#### 引入 less\n\n首先安装需要的库\n\n```\nnpm install --save @zeit/next-less less\n```\n\n然后把 mylayout 和 header 里面的行内样式去掉\n\n新建 assets/css/styles.less\n\n```\n.header {\n  display: block;\n  z-index: 500;\n  width: 100%;\n  height: 60px;\n  font-size: 14px;\n  background: #fff;\n  color: rgba(0, 0, 0, 0.44);\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen,\n    Ubuntu, Cantarell, \"Open Sans\", \"Helvetica Neue\", sans-serif;\n  letter-spacing: 0;\n  font-weight: 400;\n  font-style: normal;\n  box-sizing: border-box;\n  top: 0;\n\n  &:after {\n    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.07);\n    display: block;\n    position: absolute;\n    top: 60px;\n    color: rgba(0, 0, 0, 0.07);\n    content: \"\";\n    width: 100%;\n    height: 2px;\n  }\n\n .header-inner {\n    width: 1000px;\n    margin: 0 auto;\n\n    a {\n      height: 60px;\n      line-height: 60px;\n      font-size: 18px;\n      color: #c7c7c7;\n      cursor: pointer;\n      margin-right: 25px;\n      &:hover {\n        font-size: 18px;\n        color: #2d2d2f;\n      }\n    }\n  }\n}\n\n.content {\n  width: 1000px;\n  margin: 0 auto;\n  padding-top: 30px;\n}\n\n```\n\n修改 next.config.js\n\n```\n// next.config.js\nconst withLess = require('@zeit/next-less')\nmodule.exports = withLess({\n  /* config options here */\n})\n```\n\n在 MyLayout 里面引入 less\n\n```\nimport \"../assets/css/styles.less\";\n```\n\n在 localhost:6688 查看页面出现相应的样式\n\n[next-less 文档](https://github.com/zeit/next-plugins/tree/master/packages/next-less)\n\n#### 引入 antd\n\n```\nnpm install antd --save\nnpm install babel-plugin-import --save-dev\n\ntouch.babelrc\n```\n\n.babelrc\n\n```\n{\n  \"presets\": [\"next/babel\"],\n  \"plugins\": [\n    [\n      \"import\",\n      {\n        \"libraryName\": \"antd\",\n        \"style\": \"less\"\n      }\n    ]\n  ]\n}\n```\n\n之后引入 antd 的样式\n\nassets/css/styles.less\n\n```\n@import \"~antd/dist/antd.less\";\n```\n\n这时候就是正常引入 antd 的组件进行使用就可以了\n\n```\nimport { Typography, Card, Avatar } from \"antd\";\nconst { Title, Paragraph, Text } = Typography;\n```\n\n#### 错误解决(新版问题)\n\nValidationError: Invalid options object. CSS Loader has been initialised using an options object that does not match the API schema. - options has an unknown property 'minimize'. These properties are valid: #541\n\n新版中 css-loader 和 webpack 会出现这样一个错误,这是升级过程中代码变更导致了,css-loader 已经没有 minimize 这一选项.\n\n解决方法,在 next.config.js 添加去除代码\n\n```\nconst withLess = require(\"@zeit/next-less\");\n\nif (typeof require !== \"undefined\") {\n  require.extensions[\".less\"] = file => {};\n}\n\nfunction HACK_removeMinimizeOptionFromCssLoaders(config) {\n  console.warn(\n    \"HACK: Removing `minimize` option from `css-loader` entries in Webpack config\"\n  );\n  config.module.rules.forEach(rule => {\n    if (Array.isArray(rule.use)) {\n      rule.use.forEach(u => {\n        if (u.loader === \"css-loader\" && u.options) {\n          delete u.options.minimize;\n        }\n      });\n    }\n  });\n}\n\nmodule.exports = withLess({\n  lessLoaderOptions: {\n    javascriptEnabled: true\n  },\n  webpack(config) {\n    HACK_removeMinimizeOptionFromCssLoaders(config);\n    return config;\n  }\n});\n\n```\n\n## 部署 Next.js 应用\n\n先安装 now,一个静态资源托管服务器\n\n```\nnpm i -g now\n\nnow\n```\n\n等待一段时间之后会生成一个静态链接,点击打开就可以看到自己网页的样子了https://react-next-demo.fuhuodemao.now.sh\n\n[zeit now 文档](https://zeit.co/docs#related)\n\n#### 打包生产环境代码\n\n查看 package.json 的 script\n\n```\n\"dev\": \"next -p 6688\",\n\"build\": \"next build\",\n\"start\": \"next start -p 6688\",\n```\n\n现在执行命令来生成代码并预览\n\n```\nnpm run build // 构建用于生产的Next.js应用程序\nnpm start // 在6688端口上启动Next.js应用程序.该服务器将进行服务器端渲染并提供静态页面\n```\n\n在 localhost:6688 上我们可以看到同样的效果\n\n#### 开启多个端口\n\n修改 script 命令\n\n```\n \"start\": \"next start -p 6688\",\n```\n\n然后执行`npm start`,我们可以在 localhost:8866 上再次打开一个应用\n\n在 window 下需要额外的工具 cross-env\n\n```\nnpm install cross-env --save-dev\n```\n\n## 参考\n\n- [官方文档](https://nextjs.org/docs)\n- [learn next](https://nextjs.org/learn/basics/getting-started/setup)\n- [中文文档](https://nextjs.frontendx.cn/docs)","html":"<h2 id=\"next-简介\">next 简介</h2>\n<p>next.js作为一款轻量级的应用框架，主要用于构建静态网站和后端渲染网站。</p>\n<h2 id=\"next-特点\">next 特点</h2>\n<ul>\n<li>默认情况下由服务器呈现</li>\n<li>自动代码拆分可加快页面加载速度</li>\n<li>简单的客户端路由（基于页面）</li>\n<li>基于 Webpack 的开发环境,支持热模块替换（HMR）</li>\n<li>能够与 Express 或任何其他 Node.js HTTP 服务器一起实现</li>\n<li>可使用您自己的 Babel 和 Webpack 配置进行自定义</li>\n</ul>\n<h2 id=\"系统需求\">系统需求</h2>\n<p>Next.js 可与 Windows,Mac 和 Linux 一起使用.您只需要在系统上安装 Node.js 即可开始构建 Next.js 应用程序.如果有个编辑器就更好了</p>\n<h2 id=\"初始化项目\">初始化项目</h2>\n<pre><code>mkdir next-demo //创建项目\ncd next-demo //进入项目\nnpm init -y // 快速创建package.json而不用进行一些选择\nnpm install --save react react-dom next // 安装依赖\nmkdir pages //创建pages</code></pre><p>mkdir pages 这一步是必须创建一个叫 pages 的文件夹,因为 next 是根据 pages 下面的 js jsx tsx 文件来进行路由生成,且文件夹名字必须是pages</p>\n<p>然后打开 package.json 目录中的 next-demo 文件并替换 scripts 为以下内容：</p>\n<pre><code>&quot;scripts&quot;: {\n  &quot;dev&quot;: &quot;next&quot;,\n  &quot;build&quot;: &quot;next build&quot;,\n  &quot;start&quot;: &quot;next start&quot;\n}</code></pre><p>运行以下命令以启动开发服务器：</p>\n<pre><code>npm run dev</code></pre><p>现在可以打开 localhost:3000 来查看页面效果,如果不喜欢 3000 或者端口冲突,执行下面命令</p>\n<pre><code>npm run dev -p 6688(你喜欢的端口)</code></pre><p>这时候就可以在 localhost:6688 上看到页面效果了</p>\n<h4 id=\"hello-world\">hello world</h4>\n<p>此时我们在 pages 文件夹下创建一个 index.js 作为首页</p>\n<pre><code>const Index = () =&gt; (\n  &lt;div&gt;\n    &lt;p&gt;Hello Next.js&lt;/p&gt;\n  &lt;/div&gt;\n);\n\nexport default Index;</code></pre><p>再次查看 localhost:6688 就可以看到当前页面显示出 hello world</p>\n<h2 id=\"页面间导航\">页面间导航</h2>\n<p>next 中实现路由非常的简便,新建 pages/about.js</p>\n<pre><code>export default function About() {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;This is the about page&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p>此时访问 localhost:6688/about,就可以看到页面相应的效果(路由与 pages 下的文件名称完全匹配)</p>\n<p>页面间的导航,我们可以 a 标签来进行导航.但是,它不会执行客户端导航.并且,每次点击浏览器将向服务器请求下一页,同时刷新页面.因此,为了支持客户端导航,,我们需要使用 Next.js 的 Link API,该 API 通过导出 next/link. Link 将预取页面,并且导航将在不刷新页面的情况下进行.</p>\n<h4 id=\"使用-link-api\">使用 Link API</h4>\n<p>修改 pages/index.js</p>\n<pre><code>import Link from &#39;next/link&#39;;\n\nconst Index = () =&gt; (\n  &lt;div&gt;\n    &lt;Link href=&quot;/about&quot;&gt;\n      &lt;a&gt;About Page&lt;/a&gt;\n    &lt;/Link&gt;\n    &lt;p&gt;Hello Next.js&lt;/p&gt;\n  &lt;/div&gt;\n);\n\nexport default Index;</code></pre><p>再次访问 localhost:6688,然后点击 About Page 跳转到 about 页面.之后点击浏览器的后退按钮,页面能够回到 index.</p>\n<blockquote>\n<p>Link组件默认是将路由push进入浏览器记录,所以点击后退按钮是返回上一页.这一默认形式可以替换为replace,更改为<code>&lt;Link href=&quot;/about&quot; replace&gt;</code></p>\n</blockquote>\n<p>因为 next/link 只是一个更高阶的组件(高阶组件) , next/link 组件上的设置 props 无效.只接受 href 和类似的 props.如果需要向其添加 props,则需要对下级组件进行添加. next/link 组件不会将那些 props 传递给子组件,并且还会给你一个错误警告.在这种情况下,next/link 组件的子组件/元素是接受样式和其他 props 最好对象.它可以是任何组件或标签,唯一要求是能够接受 onClick 事件.</p>\n<blockquote>\n<p>如果将功能组件作为子组件进行传递,则需要将功能组件包装<code>React.forwardRef</code>才能在<code>&lt;Link&gt;</code>使用</p>\n</blockquote>\n<pre><code>  &lt;Link href=&quot;/about&quot;&gt;\n    &lt;a className=&quot;redLink&quot;&gt;About Page&lt;/a&gt;\n  &lt;/Link&gt;\n\n  &lt;Link href=&quot;/show&quot;&gt;\n    &lt;div&gt;Show Page&lt;/div&gt;\n  &lt;/Link&gt;</code></pre><blockquote>\n<p>这是客户端导航；该操作在浏览器中进行,而无需向服务器发出请求.打开开发者工具 networks 进行查看</p>\n</blockquote>\n<p>另外的客户端导航是Router</p>\n<pre><code>import Router from &#39;next/router&#39;\n\nfunction Index() {\n  return (\n   &lt;div&gt;\n      Click &lt;span onClick={() =&gt; Router.push(&#39;/about&#39;)}&gt;here&lt;/span&gt; to read more\n    &lt;/div&gt;\n  )\n}\n\nexport default Index</code></pre><p><a href=\"https://nextjs.org/docs/#routing\">Next.js更多关于路由route的内容</a></p>\n<blockquote>\n<p>尽管实现代码的过程中以及官方案例中在Link组件里将a标签作为子元素传进去,但是实际使用中,a标签会造成路由切换失效的情况,酌情使用其他标签代替.</p>\n</blockquote>\n<h2 id=\"组件\">组件</h2>\n<p>目前 Next.js 代码都是关于页面的.我们可以通过导出 React 组件并将该组件放入 pages 目录来创建页面.然后,它将具有基于文件名的固定 URL. 但同时一些共享组件也是项目中必须的,我们将创建一个公共的 Header 组件并将其用于多个页面.</p>\n<h4 id=\"创建公用组件\">创建公用组件</h4>\n<p>新建 components/Header.js</p>\n<pre><code>import Link from &quot;next/link&quot;;\n\nconst linkStyle = {\n  marginRight: 15\n};\n\nconst Header = () =&gt; (\n  &lt;div&gt;\n    &lt;Link href=&quot;/&quot;&gt;\n      &lt;a style={linkStyle}&gt;Home&lt;/a&gt;\n    &lt;/Link&gt;\n    &lt;Link href=&quot;/about&quot;&gt;\n      &lt;a style={linkStyle}&gt;About&lt;/a&gt;\n    &lt;/Link&gt;\n    &lt;Link href=&quot;/show&quot;&gt;\n      &lt;a style={linkStyle}&gt;Show&lt;/a&gt;\n    &lt;/Link&gt;\n  &lt;/div&gt;\n);\n\nexport default Header;</code></pre><p>然后修改 pages 目录下的 index.js / about.js / show.js</p>\n<pre><code>import Header from &#39;../components/Header&#39;;\n\nexport default function Show() {\n  return (\n    &lt;div&gt;\n      &lt;Header /&gt;\n      &lt;p&gt;Hello Next.js&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p>打开 localhost:6688 点击 3 个 link 按钮就可以进行页面间的来回跳转了</p>\n<blockquote>\n<p>当前所使用的components这个名字并不是必须的,你可以将这个文件夹命名为任何名称.next中固定且不能改变的文件夹只有两个&#39;pages&#39;和&#39;static&#39;.next也并不限制将公共组件存放在pages里面,但最好不要在 pages 里面创建共享组件,这样会生成许多无效的路由.</p>\n</blockquote>\n<h4 id=\"layout-组件\">layout 组件</h4>\n<p>在我们的应用中,我们将在各个页面上使用通用样式.为此,我们可以创建一个通用的 Layout 组件并将其用于我们的每个页面.</p>\n<p>components/MyLayout.js</p>\n<pre><code>import Header from &#39;./Header&#39;;\n\nconst layoutStyle = {\n  margin: 20,\n  padding: 20,\n  border: &#39;1px solid #DDD&#39;\n};\n\nconst Layout = props =&gt; (\n  &lt;div style={layoutStyle}&gt;\n    &lt;Header /&gt;\n    {props.children}\n  &lt;/div&gt;\n);\n\nexport default Layout;</code></pre><p>然后修改 pages 目录下的 index.js / about.js / show.js</p>\n<pre><code>import Layout from &#39;../components/MyLayout&#39;;\n\nexport default function Show() {\n  return (\n    &lt;Layout&gt;\n      &lt;p&gt;Hello Next.js&lt;/p&gt;\n    &lt;/Layout&gt;\n  );\n}</code></pre><p>此外还可以使用 hoc 组件进行内容传递获取使用 props 属性进行传递.最终实现的是布局组件实现了多页面共用.</p>\n<h2 id=\"动态页面\">动态页面</h2>\n<p>在实际应用中,我们需要创建动态页面来显示动态内容.</p>\n<p>首先修改 pages/about.js 文件</p>\n<pre><code>import Layout from &quot;../components/MyLayout&quot;;\nimport Link from &quot;next/link&quot;;\n\nconst PostLink = props =&gt; (\n  &lt;li&gt;\n    &lt;Link href={`/post?title=${props.title}`}&gt;\n      &lt;a&gt;{props.title}&lt;/a&gt;\n    &lt;/Link&gt;\n  &lt;/li&gt;\n);\n\nexport default function About() {\n  return (\n    &lt;Layout&gt;\n      &lt;h1&gt;My Blog&lt;/h1&gt;\n      &lt;ul&gt;\n        &lt;PostLink title=&quot;Hello Next.js&quot; /&gt;\n        &lt;PostLink title=&quot;Learn Next.js is awesome&quot; /&gt;\n        &lt;PostLink title=&quot;Deploy apps with Zeit&quot; /&gt;\n      &lt;/ul&gt;\n    &lt;/Layout&gt;\n  );\n}</code></pre><p>同样的效果Link使用对象形式</p>\n<pre><code>&lt;Link href={{ pathname: &#39;/post&#39;, query: { title: &#39;this is title&#39; } }}&gt;</code></pre><p>依然同样的效果使用Router</p>\n<pre><code>import Router from &#39;next/router&#39;\n\nconst handler = () =&gt; {\n  Router.push({\n    pathname: &#39;/about&#39;,\n    query: { name: &#39;this is title },\n  })\n}</code></pre><p>Router.push(url, as)与Link组件使用了相同的参数,第一个参数就是url,如果有第二参数,就是对应as</p>\n<p>创建 pages/post.js</p>\n<pre><code>import { useRouter } from &#39;next/router&#39;;\nimport Layout from &#39;../components/MyLayout&#39;;\n\nconst Page = () =&gt; {\n  const router = useRouter();\n\n  return (\n    &lt;Layout&gt;\n      &lt;h1&gt;{router.query.title}&lt;/h1&gt;\n      &lt;p&gt;This is the blog post content.&lt;/p&gt;\n    &lt;/Layout&gt;\n  );\n};\n\nexport default Page;</code></pre><p>打开 localhost:6688 查看页面效果,点击 about 下面的 3 个帖子,会出现对应的 title 页面</p>\n<ul>\n<li>我们通过查询字符串参数（查询参数）传递数据,通过查询字符串传递任何类型的数据.</li>\n<li>我们导入并使用 useRouter 函数,next/router 函数将返回 Next.js router 对象.</li>\n<li>我们使用 query 获取查询字符串参数</li>\n<li>获得标题需要的参数 router.query.title.</li>\n</ul>\n<p>post 页面也可以添加通用 header</p>\n<pre><code>import { useRouter } from &quot;next/router&quot;;\nimport Layout from &quot;../components/MyLayout&quot;;\n\nconst Content = () =&gt; {\n  const router = useRouter();\n\n  return (\n    &lt;Layout&gt;\n      &lt;h1&gt;{router.query.title}&lt;/h1&gt;\n      &lt;p&gt;This is the blog post content.&lt;/p&gt;\n    &lt;/Layout&gt;\n  );\n};\n\nconst Page = () =&gt; (\n  &lt;Layout&gt;\n    &lt;Content /&gt;\n  &lt;/Layout&gt;\n);\n\nexport default Page;</code></pre><p>再次查看 localhost:6688 看看不同,现在的页面也具有一套完整的布局.</p>\n<h4 id=\"路由事件\">路由事件</h4>\n<p>可以通过Router监听路由器内部发生的不同事件</p>\n<pre><code>// 监听\nRouter.events.on(&#39;routeChangeStart&#39;, handleRouteChange)\n// 关闭\nRouter.events.off(&#39;routeChangeStart&#39;, handleRouteChange)</code></pre><ul>\n<li>routeChangeStart(url) 当路由开始改变时触发</li>\n<li>routeChangeComplete(url) 路由完全改变时触发</li>\n<li>routeChangeError(err, url) 更改路由时发生错误或取消路由负载时触发</li>\n<li>beforeHistoryChange(url) 在更改浏览器的历史记录之前触发</li>\n<li>hashChangeStart(url) 当哈希值改变但页面不改变时触发</li>\n<li>hashChangeComplete(url) 哈希值更改但页面未更改时触发</li>\n</ul>\n<blockquote>\n<p>官方表示getInitialProps情况下不建议使用路由器事件.如果需要最好是在组件加载后或者某些事件后进行监听.</p>\n</blockquote>\n<h2 id=\"动态路由\">动态路由</h2>\n<p>当前我们的路由是这样的 <a href=\"http://localhost:6688/post?title=Hello%20Next.js\">http://localhost:6688/post?title=Hello%20Next.js</a> , 现在需要更干净的路由 <a href=\"http://localhost:6688/p/10\">http://localhost:6688/p/10</a>. 添加新页面来创建我们的第一个动态路由 p/[id].js</p>\n<p>新建 pages/p/[id].js</p>\n<pre><code>import { useRouter } from &#39;next/router&#39;;\nimport Layout from &#39;../../components/MyLayout&#39;;\n\nexport default function Post() {\n  const router = useRouter();\n\n  return (\n    &lt;Layout&gt;\n      &lt;h1&gt;{router.query.id}&lt;/h1&gt;\n      &lt;p&gt;This is the blog post content.&lt;/p&gt;\n    &lt;/Layout&gt;\n  );\n}</code></pre><ul>\n<li>next 会处理后面的路由/p/.例如,/p/hello-nextjs 将由此页面处理.而/p/post-1/another 不会.</li>\n<li>方括号使其成为动态路由.而且在匹配动态路由的时候必须使用全名,无法添加前缀或者后缀.例如,/pages/p/[id].js 受支持,但/pages/p/post-[id].js 不受支持.</li>\n<li>创建动态路由时,我们 id 放在方括号之间.这是页面接收到的查询参数的名称,因此/p/hello-nextjs 在 query 对象就是{ id: &#39;hello-nextjs&#39;},我们可以使用 useRouter（）进行访问.</li>\n</ul>\n<blockquote>\n<p><code>useRouter</code>是一个React钩子函数,它不能与类一起使用.类组件可以使用<code>withRouter</code>高阶组件或将类包装在功能组件中.同时withRouter也可以直接用于功能组件中.</p>\n</blockquote>\n<p>在链接多个页面,新建 pages/page.js</p>\n<pre><code>import Layout from &#39;../components/MyLayout&#39;;\nimport Link from &#39;next/link&#39;;\n\nconst PostLink = props =&gt; (\n  &lt;li&gt;\n    &lt;Link href=&quot;/p/[id]&quot; as={`/p/${props.id}`}&gt;\n      &lt;a&gt;{props.id}&lt;/a&gt;\n    &lt;/Link&gt;\n  &lt;/li&gt;\n);\n\nexport default function Blog() {\n  return (\n    &lt;Layout&gt;\n      &lt;h1&gt;My Blog&lt;/h1&gt;\n      &lt;ul&gt;\n        &lt;PostLink id=&quot;hello-nextjs&quot; /&gt;\n        &lt;PostLink id=&quot;learn-nextjs&quot; /&gt;\n        &lt;PostLink id=&quot;deploy-nextjs&quot; /&gt;\n      &lt;/ul&gt;\n    &lt;/Layout&gt;\n  );\n}</code></pre><p><code>&lt;Link href={</code>/p?id=${item.id}<code>} as={</code>/p/${item.id}<code>}&gt;</code>,访问路径就是<a href=\"http://localhost:6688/p/975\">http://localhost:6688/p/975</a></p>\n<p><code>&lt;Link href={</code>/p?id=${item.id}<code>}&gt;</code>,访问路径就是<a href=\"http://localhost:6688/p?id=975\">http://localhost:6688/p?id=975</a></p>\n<p><code>&lt;Link href={</code>/p?id=${item.id}<code>} as={</code>/post/${item.id}<code>}&gt;</code>,起别名<a href=\"http://localhost:6688/post/975\">http://localhost:6688/post/975</a></p>\n<p>在该页面中我们看一下<Link>元素,其中 href 属性 p 文件夹中页面的路径, as 是要在浏览器的 URL 栏中显示的 URL,这是next官方提供的一个路由遮挡功能,用来隐藏原本复杂的路由,显示出来简洁的路由.使网站路径更简洁.as 通常是用来与浏览器历史记录配合使用.</p>\n<h2 id=\"获取远程数据\">获取远程数据</h2>\n<p>实际上,我们通常需要从远程数据源获取数据.Next.js 自己有标准 API 来获取页面数据.我们通常使用异步函数 getInitialProps 来完成此操作 .这样,我们可以通过远程数据源获取数据到页面上,并将其作为 props 传递给我们的页面.getInitialProps 在服务器和客户端上均可使用.</p>\n<p>首先需要一个获取数据的库</p>\n<pre><code>npm install --save isomorphic-unfetch</code></pre><p>然后修改 pages/index.js</p>\n<pre><code>import Layout from &#39;../components/MyLayout&#39;;\nimport Link from &#39;next/link&#39;;\nimport fetch from &#39;isomorphic-unfetch&#39;;\n\nconst Index = props =&gt; (\n  &lt;Layout&gt;\n    &lt;h1&gt;Batman TV Shows&lt;/h1&gt;\n    &lt;ul&gt;\n      {props.shows.map(show =&gt; (\n        &lt;li key={show.id}&gt;\n          &lt;Link href=&quot;/detail/[id]&quot; as={`/detail/${show.id}`}&gt;\n            &lt;a&gt;{show.name}&lt;/a&gt;\n          &lt;/Link&gt;\n        &lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  &lt;/Layout&gt;\n);\n\nIndex.getInitialProps = async function() {\n  const res = await fetch(&#39;https://api.tvmaze.com/search/shows?q=batman&#39;);\n  const data = await res.json();\n\n  return {\n    shows: data.map(entry =&gt; entry.show)\n  };\n};\n\nexport default Index;</code></pre><p>现在这种情况下,我们只会在服务器上获取数据,因为我们是在服务端进行渲染.</p>\n<p>再创建一个详情页,这里用到了动态路由</p>\n<p>新建 pages/detail/[id].js</p>\n<pre><code>import Layout from &quot;../../components/MyLayout&quot;;\nimport fetch from &quot;isomorphic-unfetch&quot;;\nimport Markdown from &quot;react-markdown&quot;;\n\nconst Post = props =&gt; (\n  &lt;Layout&gt;\n    &lt;h1&gt;{props.show.name}&lt;/h1&gt;\n    &lt;div className=&quot;markdown&quot;&gt;\n      &lt;Markdown source={props.show.summary.replace(/&lt;[/]?p&gt;/g, &quot;&quot;)} /&gt;\n    &lt;/div&gt;\n    &lt;img src={props.show.image.medium} /&gt;\n    &lt;style jsx global&gt;{`\n     .markdown {\n        font-family: &quot;Arial&quot;;\n      }\n\n     .markdown a {\n        text-decoration: none;\n        color: blue;\n      }\n\n     .markdown a:hover {\n        opacity: 0.6;\n      }\n\n     .markdown h3 {\n        margin: 0;\n        padding: 0;\n        text-transform: uppercase;\n      }\n    `}&lt;/style&gt;\n  &lt;/Layout&gt;\n);\n\nPost.getInitialProps = async function(context) {\n  const { id } = context.query;\n  const res = await fetch(`https://api.tvmaze.com/shows/${id}`);\n  const show = await res.json();\n\n  return { show };\n};\n\nexport default Post;</code></pre><p>点击 list 中的随便一个,然后打开控制台和浏览器的 networks,会发现这次是在浏览器端进行接口请求.</p>\n<p>getInitialProps 上下文对象context具有以下属性</p>\n<ul>\n<li>pathname -URL的路径部分</li>\n<li>query -URL的查询字符串部分被解析为对象</li>\n<li>asPath- String实际路径（包括查询）的-在浏览器中显示</li>\n<li>req -HTTP请求对象（仅服务器）</li>\n<li>res -HTTP响应对象（仅服务器）</li>\n<li>err -渲染期间遇到任何错误的错误对象</li>\n</ul>\n<h2 id=\"给组件添加样式\">给组件添加样式</h2>\n<p>Next.js 在 JS 框架中预加载了一个称为 styled-jsx 的 CSS,该 CSS 使你的代码编写更轻松.它允许您为组件编写熟悉的 CSS 规则.规则对组件（甚至子组件）以外的任何东西都没有影响.简单来说就是带有作用域的 css.</p>\n<p>修改 pages/page.js</p>\n<pre><code>import Layout from &quot;../components/MyLayout&quot;;\nimport Link from &quot;next/link&quot;;\n\nfunction getPosts() {\n  return [\n    { id: &quot;hello-nextjs&quot;, title: &quot;Hello Next.js&quot; },\n    { id: &quot;learn-nextjs&quot;, title: &quot;Learn Next.js is awesome&quot; },\n    { id: &quot;deploy-nextjs&quot;, title: &quot;Deploy apps with ZEIT&quot; }\n  ];\n}\n\nexport default function Blog() {\n  return (\n    &lt;Layout&gt;\n      &lt;h1&gt;My Blog&lt;/h1&gt;\n      &lt;ul&gt;\n        {getPosts().map(post =&gt; (\n          &lt;li key={post.id}&gt;\n            &lt;Link href=&quot;/p/[id]&quot; as={`/p/${post.id}`}&gt;\n              &lt;a&gt;{post.title}&lt;/a&gt;\n            &lt;/Link&gt;\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;style jsx&gt;{`\n        h1,\n        a {\n          font-family: &quot;Arial&quot;;\n        }\n\n        ul {\n          padding: 0;\n        }\n\n        li {\n          list-style: none;\n          margin: 5px 0;\n        }\n\n        a {\n          text-decoration: none;\n          color: red;\n        }\n\n        a:hover {\n          opacity: 0.6;\n        }\n      `}&lt;/style&gt;\n    &lt;/Layout&gt;\n  );\n}</code></pre><p>在上面的代码中,我们直接写在模板字符串中,而且必须使用模板字符串（{``}）编写 CSS .</p>\n<p>此时修改一下代码</p>\n<pre><code>import Layout from &quot;../components/MyLayout&quot;;\nimport Link from &quot;next/link&quot;;\n\nfunction getPosts() {\n  return [\n    { id: &quot;hello-nextjs&quot;, title: &quot;Hello Next.js&quot; },\n    { id: &quot;learn-nextjs&quot;, title: &quot;Learn Next.js is awesome&quot; },\n    { id: &quot;deploy-nextjs&quot;, title: &quot;Deploy apps with ZEIT&quot; }\n  ];\n}\n\nconst PostLink = ({ post }) =&gt; (\n  &lt;li&gt;\n    &lt;Link href=&quot;/p/[id]&quot; as={`/p/${post.id}`}&gt;\n      &lt;a&gt;{post.title}&lt;/a&gt;\n    &lt;/Link&gt;\n  &lt;/li&gt;\n);\n\nexport default function Blog() {\n  return (\n    &lt;Layout&gt;\n      &lt;h1&gt;My Blog&lt;/h1&gt;\n      &lt;ul&gt;\n        {getPosts().map(post =&gt; (\n          &lt;PostLink key={post.id} post={post} /&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;style jsx&gt;{`\n        h1,\n        a {\n          font-family: &quot;Arial&quot;;\n        }\n\n        ul {\n          padding: 0;\n        }\n\n        li {\n          list-style: none;\n          margin: 5px 0;\n        }\n\n        a {\n          text-decoration: none;\n          color: blue;\n        }\n\n        a:hover {\n          opacity: 0.6;\n        }\n      `}&lt;/style&gt;\n    &lt;/Layout&gt;\n  );\n}</code></pre><p>这时候打开浏览器观察就会发现也是不生效,这是因为 style jsx 这种写法样式是有作用域,css 只能在当前作用域下生效.</p>\n<p>解决 1 , 给子组件添加上子组件的样式</p>\n<pre><code>const PostLink = ({ post }) =&gt; (\n  &lt;li&gt;\n    &lt;Link href=&quot;/p/[id]&quot; as={`/p/${post.id}`}&gt;\n      &lt;a&gt;{post.title}&lt;/a&gt;\n    &lt;/Link&gt;\n    &lt;style jsx&gt;{`\n      li {\n        list-style: none;\n        margin: 5px 0;\n      }\n\n      a {\n        text-decoration: none;\n        color: blue;\n        font-family: &#39;Arial&#39;;\n      }\n\n      a:hover {\n        opacity: 0.6;\n      }\n    `}&lt;/style&gt;\n  &lt;/li&gt;\n);</code></pre><p>解决 2 , <a href=\"https://github.com/zeit/styled-jsx#one-off-global-selectors\">全局样式</a></p>\n<pre><code> &lt;style jsx global&gt;{`\n......css\n `}</code></pre><p>一般不使用全局样式来解决</p>\n<p><a href=\"https://www.npmjs.com/package/styled-jsx\">styled-jsx 文档</a></p>\n<h4 id=\"使用全局样式\">使用全局样式</h4>\n<p>有时,我们确实需要更改子组件内部的样式.尤其是使用一些第三方库样式又有些不满意的时候.</p>\n<p>安装 react-markdown</p>\n<pre><code>npm install --save react-markdown</code></pre><p>修改 pages/post.js</p>\n<pre><code>import { useRouter } from &quot;next/router&quot;;\nimport Layout from &quot;../components/MyLayout&quot;;\nimport Markdown from &quot;react-markdown&quot;;\n\nconst Content = () =&gt; {\n  const router = useRouter();\n\n  return (\n    &lt;Layout&gt;\n      &lt;h1&gt;{router.query.title}&lt;/h1&gt;\n      &lt;div className=&quot;markdown&quot;&gt;\n        &lt;Markdown\n          source={`  # Live demo\n\n                  Changes are automatically rendered as you type.\n\n                  ## Table of Contents\n\n                  * Implements [GitHub Flavored Markdown](https://github.github.com/gfm/)\n                  * Renders actual, &quot;native&quot; React DOM elements\n                  * Allows you to escape or skip HTML (try toggling the checkboxes above)\n                  * If you escape or skip the HTML, no dangerouslySetInnerHTML is used! Yay!\n\n                  ## HTML block below\n\n                &lt;blockquote&gt;\n                  This blockquote will change based on the HTML settings above.\n                &lt;/blockquote&gt;`\n            }\n        /&gt;\n      &lt;/div&gt;\n      &lt;style jsx global&gt;{`\n       .markdown {\n          font-family: &quot;Arial&quot;;\n        }\n\n       .markdown a {\n          text-decoration: none;\n          color: blue;\n        }\n\n       .markdown a:hover {\n          opacity: 0.6;\n        }\n\n       .markdown h3 {\n          margin: 0;\n          padding: 0;\n          text-transform: uppercase;\n        }\n      `}&lt;/style&gt;\n    &lt;/Layout&gt;\n  );\n};\n\nconst Page = () =&gt; (\n  &lt;Layout&gt;\n    &lt;Content /&gt;\n  &lt;/Layout&gt;\n);\n\nexport default Page;</code></pre><p>打开 localhost:6688 的 about 页面点击查看样式效果</p>\n<p><a href=\"https://github.com/zeit/next.js#css-in-js\">其他解决方案</a></p>\n<h2 id=\"引入-ui-库\">引入 ui 库</h2>\n<p>目前代码在页面中呈现的样式是比较随意的,秉承着能打开就行的原则开发到这一步,是否应该稍微美化一下下.</p>\n<h4 id=\"引入-less\">引入 less</h4>\n<p>首先安装需要的库</p>\n<pre><code>npm install --save @zeit/next-less less</code></pre><p>然后把 mylayout 和 header 里面的行内样式去掉</p>\n<p>新建 assets/css/styles.less</p>\n<pre><code>.header {\n  display: block;\n  z-index: 500;\n  width: 100%;\n  height: 60px;\n  font-size: 14px;\n  background: #fff;\n  color: rgba(0, 0, 0, 0.44);\n  font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen,\n    Ubuntu, Cantarell, &quot;Open Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;\n  letter-spacing: 0;\n  font-weight: 400;\n  font-style: normal;\n  box-sizing: border-box;\n  top: 0;\n\n  &amp;:after {\n    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.07);\n    display: block;\n    position: absolute;\n    top: 60px;\n    color: rgba(0, 0, 0, 0.07);\n    content: &quot;&quot;;\n    width: 100%;\n    height: 2px;\n  }\n\n .header-inner {\n    width: 1000px;\n    margin: 0 auto;\n\n    a {\n      height: 60px;\n      line-height: 60px;\n      font-size: 18px;\n      color: #c7c7c7;\n      cursor: pointer;\n      margin-right: 25px;\n      &amp;:hover {\n        font-size: 18px;\n        color: #2d2d2f;\n      }\n    }\n  }\n}\n\n.content {\n  width: 1000px;\n  margin: 0 auto;\n  padding-top: 30px;\n}\n</code></pre><p>修改 next.config.js</p>\n<pre><code>// next.config.js\nconst withLess = require(&#39;@zeit/next-less&#39;)\nmodule.exports = withLess({\n  /* config options here */\n})</code></pre><p>在 MyLayout 里面引入 less</p>\n<pre><code>import &quot;../assets/css/styles.less&quot;;</code></pre><p>在 localhost:6688 查看页面出现相应的样式</p>\n<p><a href=\"https://github.com/zeit/next-plugins/tree/master/packages/next-less\">next-less 文档</a></p>\n<h4 id=\"引入-antd\">引入 antd</h4>\n<pre><code>npm install antd --save\nnpm install babel-plugin-import --save-dev\n\ntouch.babelrc</code></pre><p>.babelrc</p>\n<pre><code>{\n  &quot;presets&quot;: [&quot;next/babel&quot;],\n  &quot;plugins&quot;: [\n    [\n      &quot;import&quot;,\n      {\n        &quot;libraryName&quot;: &quot;antd&quot;,\n        &quot;style&quot;: &quot;less&quot;\n      }\n    ]\n  ]\n}</code></pre><p>之后引入 antd 的样式</p>\n<p>assets/css/styles.less</p>\n<pre><code>@import &quot;~antd/dist/antd.less&quot;;</code></pre><p>这时候就是正常引入 antd 的组件进行使用就可以了</p>\n<pre><code>import { Typography, Card, Avatar } from &quot;antd&quot;;\nconst { Title, Paragraph, Text } = Typography;</code></pre><h4 id=\"错误解决新版问题\">错误解决(新版问题)</h4>\n<p>ValidationError: Invalid options object. CSS Loader has been initialised using an options object that does not match the API schema. - options has an unknown property &#39;minimize&#39;. These properties are valid: #541</p>\n<p>新版中 css-loader 和 webpack 会出现这样一个错误,这是升级过程中代码变更导致了,css-loader 已经没有 minimize 这一选项.</p>\n<p>解决方法,在 next.config.js 添加去除代码</p>\n<pre><code>const withLess = require(&quot;@zeit/next-less&quot;);\n\nif (typeof require !== &quot;undefined&quot;) {\n  require.extensions[&quot;.less&quot;] = file =&gt; {};\n}\n\nfunction HACK_removeMinimizeOptionFromCssLoaders(config) {\n  console.warn(\n    &quot;HACK: Removing `minimize` option from `css-loader` entries in Webpack config&quot;\n  );\n  config.module.rules.forEach(rule =&gt; {\n    if (Array.isArray(rule.use)) {\n      rule.use.forEach(u =&gt; {\n        if (u.loader === &quot;css-loader&quot; &amp;&amp; u.options) {\n          delete u.options.minimize;\n        }\n      });\n    }\n  });\n}\n\nmodule.exports = withLess({\n  lessLoaderOptions: {\n    javascriptEnabled: true\n  },\n  webpack(config) {\n    HACK_removeMinimizeOptionFromCssLoaders(config);\n    return config;\n  }\n});\n</code></pre><h2 id=\"部署-nextjs-应用\">部署 Next.js 应用</h2>\n<p>先安装 now,一个静态资源托管服务器</p>\n<pre><code>npm i -g now\n\nnow</code></pre><p>等待一段时间之后会生成一个静态链接,点击打开就可以看到自己网页的样子了<a href=\"https://react-next-demo.fuhuodemao.now.sh\">https://react-next-demo.fuhuodemao.now.sh</a></p>\n<p><a href=\"https://zeit.co/docs#related\">zeit now 文档</a></p>\n<h4 id=\"打包生产环境代码\">打包生产环境代码</h4>\n<p>查看 package.json 的 script</p>\n<pre><code>&quot;dev&quot;: &quot;next -p 6688&quot;,\n&quot;build&quot;: &quot;next build&quot;,\n&quot;start&quot;: &quot;next start -p 6688&quot;,</code></pre><p>现在执行命令来生成代码并预览</p>\n<pre><code>npm run build // 构建用于生产的Next.js应用程序\nnpm start // 在6688端口上启动Next.js应用程序.该服务器将进行服务器端渲染并提供静态页面</code></pre><p>在 localhost:6688 上我们可以看到同样的效果</p>\n<h4 id=\"开启多个端口\">开启多个端口</h4>\n<p>修改 script 命令</p>\n<pre><code> &quot;start&quot;: &quot;next start -p 6688&quot;,</code></pre><p>然后执行<code>npm start</code>,我们可以在 localhost:8866 上再次打开一个应用</p>\n<p>在 window 下需要额外的工具 cross-env</p>\n<pre><code>npm install cross-env --save-dev</code></pre><h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://nextjs.org/docs\">官方文档</a></li>\n<li><a href=\"https://nextjs.org/learn/basics/getting-started/setup\">learn next</a></li>\n<li><a href=\"https://nextjs.frontendx.cn/docs\">中文文档</a></li>\n</ul>\n"}
