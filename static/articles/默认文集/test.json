{
  "markdown": "## 导出 html 并开启服务\n\n我们将 pages 下页面导出为静态 HTML 页面.首先,next.config.js 在应用程序的根目录中创建一个名为的文件,并添加以下内容\n\n```\nexportPathMap: async function() {\n    return {\n        \"/\": { page: \"/\" },\n        \"/books\": { page: \"/books\" },\n        \"/article\": { page: \"/article\" },\n        \"/write\": { page: \"/write\" }\n    };\n},\n```\n\n然后打开 package.json 并添加 scripts 为以下内容：\n\n```\n  \"build\": \"next build\",\n  \"export\": \"next export\"\n```\n\n现在,您可以 out 在项目内部的目录中看到导出的 HTML 内容.\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%881.56.14.png)\n\n现在需要在本地开启一个静态服务器,进行测试\n\n```\nnpm install -g serve\n\ncd out\n\nserve -p 8866\n```\n\n> serve 是一个非常简单的静态 Web 服务器\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%881.59.25.png)\n\n## 导出其他页面\n\n将以下内容添加到 next.config.js 文件中：\n\n```\n  exportPathMap: async function() {\n    const paths = {\n      \"/\": { page: \"/\" },\n      \"/books\": { page: \"/books\" },\n      \"/article\": { page: \"/article\" },\n      \"/write\": { page: \"/write\" }\n    };\n\n    const res = await fetch(\"https://api.tvmaze.com/search/shows?q=batman\");\n    const data = await res.json();\n    const shows = data.map(entry => entry.show);\n\n    shows.forEach(show => {\n      paths[`/book/${show.id}`] = {\n        page: \"/book/[id]\",\n        query: { id: show.id }\n      };\n    });\n\n    return paths;\n  },\n```\n\n为了渲染详情页面,我们首先获取数据列表.然后,我们循环获取 id,并为其添加新路径并进行查询.\n\n关闭本地服务器并在次执行\n\n```\nnpm run export\n\ncd out\n\nserve -p 8080\n```\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%882.14.31.png)\n\n> 运行 next export 命令时,Next.js 不会构建应用程序.页面/book/[id]已经存在于构建中,因此无需再次构建整个应用程序.但是,如果我们对应用程序进行了任何更改,则需要再次构建应用程序以获取这些更改,就是在执行一个 npm run build\n\n## 添加 typescript\n\n```\nnpm install --save-dev typescript @types/react @types/node @types/react-dom\n```\n\n将 index.js 更改为 index.tsx\n\n生成的 tsconfig.json\n\n```\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"target\": \"es5\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\"\n  },\n  \"exclude\": [\"node_modules\"],\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\"]\n}\n```\n\nindex.tsx 页面提示缺少类型,因为我们没有告诉 TypeScript 它是 Next.js 页面,在 strict 模式下不允许隐式 any 类型.\n\n```\nimport { NextPage } from 'next';\n\nconst Home: NextPage<{ userAgent: string }> = ({ userAgent }) => (\n  <h1>Hello world! - user agent: {userAgent}</h1>\n);\n\nHome.getInitialProps = async ({ req }) => {\n  const userAgent = req ? req.headers['user-agent'] || '' : navigator.userAgent;\n  return { userAgent };\n};\n\nexport default Home;\n```\n\n## 懒加载模块\n\n#### 创建 firebase 页面\n\n整体项目代码 [官方案例](https://github.com/zeit/next-learn-demo/tree/master/E2-lazy-loading-modules)\n\n#### 添加 analyzer\n\n安装依赖包\n\n```\nnpm install firebase @zeit/next-bundle-analyzer cross-env --save\n```\n\n然后打开 package.json 并添加 scripts 为以下内容：\n\n```\n\"analyze\": \"cross-env ANALYZE=true next build\",\n\"analyze:server\": \"cross-env BUNDLE_ANALYZE=server next build\",\n\"analyze:browser\": \"cross-env BUNDLE_ANALYZE=browser next build\n```\n\n现在的 next.config.js 所有配置\n\n```\nconst fetch = require(\"isomorphic-unfetch\");\nconst withBundleAnalyzer = require(\"@zeit/next-bundle-analyzer\");\nconst withLess = require(\"@zeit/next-less\");\nconst FilterWarningsPlugin = require(\"webpack-filter-warnings-plugin\");\n\nif (typeof require !== \"undefined\") {\n  require.extensions[\".less\"] = file => {};\n}\n\nfunction HACK_removeMinimizeOptionFromCssLoaders(config) {\n  config.module.rules.forEach(rule => {\n    if (Array.isArray(rule.use)) {\n      rule.use.forEach(u => {\n        if (u.loader === \"css-loader\" && u.options) {\n          delete u.options.minimize;\n        }\n      });\n    }\n  });\n}\n\nmodule.exports = withBundleAnalyzer(\n  withLess({\n    analyzeServer: [\"server\", \"both\"].includes(process.env.BUNDLE_ANALYZE),\n    analyzeBrowser: [\"browser\", \"both\"].includes(process.env.BUNDLE_ANALYZE),\n    bundleAnalyzerConfig: {\n      server: {\n        analyzerMode: \"static\",\n        reportFilename: \"../bundles/server.html\"\n      },\n      browser: {\n        analyzerMode: \"static\",\n        reportFilename: \"../bundles/client.html\"\n      }\n    },\n    exportPathMap: async function() {\n      const paths = {\n        \"/\": { page: \"/\" },\n        \"/books\": { page: \"/books\" },\n        \"/article\": { page: \"/article\" },\n        \"/write\": { page: \"/write\" }\n      };\n\n      const res = await fetch(\"https://api.tvmaze.com/search/shows?q=batman\");\n      const data = await res.json();\n      const shows = data.map(entry => entry.show);\n\n      shows.forEach(show => {\n        paths[`/book/${show.id}`] = {\n          page: \"/book/[id]\",\n          query: { id: show.id }\n        };\n      });\n\n      return paths;\n    },\n    lessLoaderOptions: {\n      javascriptEnabled: true\n    },\n    webpack(config) {\n      config.plugins.push(\n        new FilterWarningsPlugin({\n          exclude: /mini-css-extract-plugin[^]*Conflicting order between:/\n        })\n      );\n      HACK_removeMinimizeOptionFromCssLoaders(config);\n      return config;\n    }\n  })\n);\n\n```\n\n直接执行\n\n```\nnpm run analyze\n```\n\n服务器文件分析\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.11.png)\n\n客户端文件分析\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.11.png)\n\nfirebase 文件分析详情\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.29.png)\n\n可以看到当前 firebase 和 firebase/[id].js 存在对 firebase 模块的引用\n\n#### 延迟加载\n\n仅当用户尝试导航到其他页面时,我们才使用 firebase 模块.可以使用 Next.js 的动态导入功能轻松地做到这一点.\n\n修改 lib/load-db.js\n\n```\nexport default async function loadDb() {\n  const firebase = await import('firebase/app');\n  await import('firebase/database');\n\n  try {\n    firebase.initializeApp({\n      databaseURL: 'https://hacker-news.firebaseio.com'\n    });\n  } catch (err) {\n    // we skip the \"already exists\" message which is\n    // not an actual error when we're hot-reloading\n    if (!/already exists/.test(err.message)) {\n      console.error('Firebase initialization error', err.stack);\n    }\n  }\n\n  return firebase.database().ref('v0');\n}\n```\n\n使用 import()函数加载 firebase 模块,用 await 来等待并解析模块.\n\n再次执行\n\n```\nnpm run analyze\n```\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.33.png)\n\nfirebase 模块具有自己的 bundle,`static/chunks/[a-random-string].js`.当您尝试导入 firebase/app 和 firebase/database 模块时,将加载此 bundle.\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.21.png)\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.21.png)\n\n可以看到,firebse 和 firebase/[id].js 文件缩小了不少\n\n#### 进行测试\n\n由于需要更真实的测试在线上的表现,我们需要重新构建.\n\n```\nnpm run build\nnpm run start\n```\n\n然后输入 localhost:8866 (与 dev 不一样),之后进入 firebase 页面在进入 firebase 详情页面.\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.29.11.png)\n\n实际上只会第一次浏览页面时加载,当 firebase 页面导入 firebase/app 和 firebase/database 模块,会加载 firebase 的 bundle.等再次进入的时候,改 bundle 已经加载过,就不会再次加载`\n\n如图,再次加载没有请求\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.33.20.png)\n\n> 延迟加载的模块减少了主要 JavaScript 包的大小,带来了更快的加载速度\n\n## 延迟加载组件\n\n在一个组件里面同时使用 3 个 markdown 相关组件\n\n```\nimport Markdown from \"react-markdown\";\nimport marked from \"marked\";\nimport Highlight from \"react-highlight\";\n```\n\n导致这个页面过于庞大\n\n执行`npm run analyze`看看 markdown/[id]大小\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%884.47.22.png)\n\n但是我们不需要在一开始就使用这些模块,只有需要加载 markdown 文本时才需要.因此,如果我们仅在使用时才加载,那将大大减少初始 bundle,有助于页面快地加载.\n\n#### 使用 HOC 高阶组件抽离渲染\n\n新建 lib/with-post.js\n\n```\nimport Layout from \"../components/MyLayout\";\nimport dynamic from \"next/dynamic\";\nimport marked from \"marked\";\n\nconst Highlight = dynamic(() => import(\"react-highlight\"));\n\nmarked &&\n  marked.setOptions({\n    gfm: true,\n    tables: true,\n    breaks: true\n  });\n\nfunction WithPost(InnerComponent, options) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.renderMarkdown = this.renderMarkdown.bind(this);\n    }\n\n    renderMarkdown(id) {\n      // If a code snippet contains in the markdown content\n      // then use Highlight component\n      if (id === 1 || id === \"1\") {\n        return (\n          <Layout>\n            <h1>{options.title}</h1>\n            <h3>当前id=>{id}</h3>\n            <div className=\"markdown\">\n              <Highlight innerHTML>{marked(options.content)}</Highlight>\n            </div>\n          </Layout>\n        );\n      }\n\n      // If not, simply render the generated HTML from markdown\n      return (\n        <Layout>\n          <h1>{options.title}</h1>\n          <h3>当前id=>{id}</h3>\n          <div className=\"markdown\">\n            <div dangerouslySetInnerHTML={{ __html: marked(options.content) }} />\n          </div>\n        </Layout>\n      );\n    }\n\n    render() {\n      return <InnerComponent renderMarkdown={this.renderMarkdown}></InnerComponent>;\n    }\n  };\n}\n\nexport default WithPost;\n\n```\n\n修改 marked/[id].js\n\n```\nimport React, { Component } from \"react\";\nimport withPost from \"../../lib/with-post\";\nimport { withRouter } from \"next/router\";\n\nconst data = {\n  title: \"Deploy apps with ZEIT now\",\n  content: `\n          Deploying apps to ZEIT now is pretty easy.\n          Simply run the following command from your app root:\n          ~~~bash\n          npm i -g now # one time command\n          now\n          ~~~\n        `\n};\n\nclass Post extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return <div>{this.props.renderMarkdown(this.props.router.query.id)}</div>;\n  }\n}\n\nPost = withRouter(Post);\nPost = withPost(Post, data);\nexport default Post;\n```\n\n现在需要使用 Next.js 中的动态导入将 react-highlight 组件转换为动态组件.最终实现这些组件仅在将要在页面中呈现时才加载.可以使用该 next/dynamic 来创建动态组件.\n\n#### 动态组件\n\n```\n//import Highlight from 'react-highlight'\nimport dynamic from 'next/dynamic';\n\nconst Highlight = dynamic(() => import('react-highlight'));\n```\n\n访问 localhost:6688,可以在 network 中找到单次 Highlight 的 bundle 引入\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.11.16.png)\n\n#### 仅在需要时加载\n\n```\nif (id === 1 || id === \"1\") {\n  return (\n    <Layout>\n      <h1>{options.title}</h1>\n      <h3>当前id=>{id}</h3>\n      <div className=\"markdown\">\n        <Highlight innerHTML>{marked(options.content)}</Highlight>\n      </div>\n    </Layout>\n  );\n}\n```\n\n当前判断 id 是否为 1,如果是就加载 Highlight,否则就正常插入 html\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.58.17.png)\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.58.17.png)\n\n使用动态组件后,就会将组件单独实现一个 bundle,加载时候直接加载这一个 bundle 就行了\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%889.40.51.png)\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%889.40.45.png)\n\n效果也是实现了 javascript 主文件的精简,同时所以 marked/[id].js 的大小,能够根据实际来判断是否加载一大段可能不需要的代码.\n\n为了模拟真实的服务器渲染效果,需要重新构建\n\n```\nnpm run build\nnpm run start\n```\n\n上图中可以看到,highlight 的 bundle 名称是 16.[chunkname].js\n\n输入http://localhost:8866/marked/1,可以在head里面发现`<link rel=\"preload\" href=\"/_next/static/chunks/commons.972eca8099a2576b25d9.js\" as=\"script\">`的存在.之后再切换为其它的 id,这一个 js 文件就没有在 head 中引入\n\n## 创建 awp 页面\n\n新建 pages/awp.js\n\n```\nexport const config = { amp: true };\n\nexport default function Awp(props) {\n  return <p>Welcome to the AMP only Index page!!</p>;\n}\n```\n\n[AMP,来自 Google 的移动页面优化方案](https://imququ.com/post/amp-project.html)\n\n通过添加 amp: 'hybrid'以下内容来创建混合 AMP 页面\n\n```\nimport { useAmp } from 'next/amp';\n\nexport const config = { amp: 'hybrid' };\n\nexport default function Awp(props) {\n  const isAmp = useAmp();\n  return <p>Welcome to the {isAmp ? 'AMP' : 'normal'} version of the Index page!!</p>;\n}\n```\n\n## 自动静态优化\n\n[自动静态优化](https://nextjs.org/docs#automatic-static-optimization)\n\n如果没有阻塞数据要求,则 Next.js 会自动确定页面为静态页面（可以预呈现）.判断标准就是 getInitialProps 在页面中是否存在.\n\n如果 getInitialProps 存在,则 Next.js 不会静态优化页面.相反,Next.js 将使用其默认行为并按请求呈现页面(即服务器端呈现).\n\n如果 getInitialProps 不存在,则 Next.js 会通过将其预呈现为静态 HTML 来自动静态优化您的页面.在预渲染期间,路由器的 query 对象将为空,因为 query 在此阶段我们没有信息要提供.query 水合后,将在客户端填充任何值.\n\n此功能允许 Next.js 发出包含服务器渲染页面和静态生成页面的混合应用程序.这样可以确保 Next.js 始终默认发出快速的应用程序.\n\n> 静态生成的页面仍然是反应性的：Next.js 将对您的应用程序客户端进行水化处理,使其具有完全的交互性.\n\n优点是优化的页面不需要服务器端计算,并且可以立即从 CDN 位置流式传输到最终用户.为用户带来超快的加载体验.\n\n- 在大多数情况下,你并不需要一个自定义的服务器,所以尝试添加 target: 'serverless'\n- getInitialProps 是页面是否静态的主要决定因素,如果不需要 SSR,请不要添加到页面\n- 并非所有动态数据都必须具有 SSR,例如,如果它在登录后,或者您不需要 SEO,那么在这种情况下,最好在外部进行获取 getInitialProps 使用静态 HTML 加载速度",
  "html": "<h2 id=\"-html-\">导出 html 并开启服务</h2>\n<p>我们将 pages 下页面导出为静态 HTML 页面.首先,next.config.js 在应用程序的根目录中创建一个名为的文件,并添加以下内容</p>\n<pre><code>exportPathMap: <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-string\">\"/\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/\"</span> },\n        <span class=\"hljs-string\">\"/books\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/books\"</span> },\n        <span class=\"hljs-string\">\"/article\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/article\"</span> },\n        <span class=\"hljs-string\">\"/write\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/write\"</span> }\n    };\n},\n</code></pre><p>然后打开 package.json 并添加 scripts 为以下内容：</p>\n<pre><code>  <span class=\"hljs-string\">\"build\"</span>: <span class=\"hljs-string\">\"next build\"</span>,\n  <span class=\"hljs-string\">\"export\"</span>: <span class=\"hljs-string\">\"next export\"</span>\n</code></pre><p>现在,您可以 out 在项目内部的目录中看到导出的 HTML 内容.</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%881.56.14.png\" alt=\"\"></p>\n<p>现在需要在本地开启一个静态服务器,进行测试</p>\n<pre><code>npm <span class=\"hljs-keyword\">install</span> -g serve\n\ncd <span class=\"hljs-keyword\">out</span>\n\nserve -p <span class=\"hljs-number\">8866</span>\n</code></pre><blockquote>\n<p>serve 是一个非常简单的静态 Web 服务器</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%881.59.25.png\" alt=\"\"></p>\n<h2 id=\"-\">导出其他页面</h2>\n<p>将以下内容添加到 next.config.js 文件中：</p>\n<pre><code>  exportPathMap: <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">const</span> paths = {\n      <span class=\"hljs-string\">\"/\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/\"</span> },\n      <span class=\"hljs-string\">\"/books\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/books\"</span> },\n      <span class=\"hljs-string\">\"/article\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/article\"</span> },\n      <span class=\"hljs-string\">\"/write\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/write\"</span> }\n    };\n\n    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">\"https://api.tvmaze.com/search/shows?q=batman\"</span>);\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> res.json();\n    <span class=\"hljs-keyword\">const</span> shows = data.map(<span class=\"hljs-function\"><span class=\"hljs-params\">entry</span> =&gt;</span> entry.show);\n\n    shows.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">show</span> =&gt;</span> {\n      paths[<span class=\"hljs-string\">`/book/<span class=\"hljs-subst\">${show.id}</span>`</span>] = {\n        <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/book/[id]\"</span>,\n        <span class=\"hljs-attr\">query</span>: { <span class=\"hljs-attr\">id</span>: show.id }\n      };\n    });\n\n    <span class=\"hljs-keyword\">return</span> paths;\n  },\n</code></pre><p>为了渲染详情页面,我们首先获取数据列表.然后,我们循环获取 id,并为其添加新路径并进行查询.</p>\n<p>关闭本地服务器并在次执行</p>\n<pre><code>npm run <span class=\"hljs-built_in\">export</span>\n\n<span class=\"hljs-built_in\">cd</span> out\n\nserve -p 8080\n</code></pre><p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%882.14.31.png\" alt=\"\"></p>\n<blockquote>\n<p>运行 next export 命令时,Next.js 不会构建应用程序.页面/book/[id]已经存在于构建中,因此无需再次构建整个应用程序.但是,如果我们对应用程序进行了任何更改,则需要再次构建应用程序以获取这些更改,就是在执行一个 npm run build</p>\n</blockquote>\n<h2 id=\"-typescript\">添加 typescript</h2>\n<pre><code><span class=\"hljs-built_in\">npm</span> install --save-dev typescript @types/react @types/node @types/react-dom\n</code></pre><p>将 index.js 更改为 index.tsx</p>\n<p>生成的 tsconfig.json</p>\n<pre><code>{\n  <span class=\"hljs-attr\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-attr\">\"experimentalDecorators\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"target\"</span>: <span class=\"hljs-string\">\"es5\"</span>,\n    <span class=\"hljs-attr\">\"lib\"</span>: [<span class=\"hljs-string\">\"dom\"</span>, <span class=\"hljs-string\">\"dom.iterable\"</span>, <span class=\"hljs-string\">\"esnext\"</span>],\n    <span class=\"hljs-attr\">\"allowJs\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"skipLibCheck\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"strict\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"forceConsistentCasingInFileNames\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"noEmit\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"esModuleInterop\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"module\"</span>: <span class=\"hljs-string\">\"esnext\"</span>,\n    <span class=\"hljs-attr\">\"moduleResolution\"</span>: <span class=\"hljs-string\">\"node\"</span>,\n    <span class=\"hljs-attr\">\"resolveJsonModule\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"isolatedModules\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"jsx\"</span>: <span class=\"hljs-string\">\"preserve\"</span>\n  },\n  <span class=\"hljs-attr\">\"exclude\"</span>: [<span class=\"hljs-string\">\"node_modules\"</span>],\n  <span class=\"hljs-attr\">\"include\"</span>: [<span class=\"hljs-string\">\"next-env.d.ts\"</span>, <span class=\"hljs-string\">\"**/*.ts\"</span>, <span class=\"hljs-string\">\"**/*.tsx\"</span>]\n}\n</code></pre><p>index.tsx 页面提示缺少类型,因为我们没有告诉 TypeScript 它是 Next.js 页面,在 strict 模式下不允许隐式 any 类型.</p>\n<pre><code><span class=\"hljs-keyword\">import</span> { NextPage } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next'</span>;\n\n<span class=\"hljs-keyword\">const</span> Home: NextPage&lt;{ <span class=\"hljs-attr\">userAgent</span>: string }&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ userAgent }</span>) =&gt;</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello world! - user agent: {userAgent}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n);\n\nHome.getInitialProps = <span class=\"hljs-keyword\">async</span> ({ req }) =&gt; {\n  <span class=\"hljs-keyword\">const</span> userAgent = req ? req.headers[<span class=\"hljs-string\">'user-agent'</span>] || <span class=\"hljs-string\">''</span> : navigator.userAgent;\n  <span class=\"hljs-keyword\">return</span> { userAgent };\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Home;\n</code></pre><h2 id=\"-\">懒加载模块</h2>\n<h4 id=\"-firebase-\">创建 firebase 页面</h4>\n<p>整体项目代码 <a href=\"https://github.com/zeit/next-learn-demo/tree/master/E2-lazy-loading-modules\">官方案例</a></p>\n<h4 id=\"-analyzer\">添加 analyzer</h4>\n<p>安装依赖包</p>\n<pre><code><span class=\"hljs-selector-tag\">npm</span> <span class=\"hljs-selector-tag\">install</span> <span class=\"hljs-selector-tag\">firebase</span> @<span class=\"hljs-keyword\">zeit</span>/<span class=\"hljs-keyword\">next</span>-<span class=\"hljs-keyword\">bundle</span>-<span class=\"hljs-keyword\">analyzer</span> cross-env --save\n</code></pre><p>然后打开 package.json 并添加 scripts 为以下内容：</p>\n<pre><code>\"<span class=\"hljs-keyword\">analyze</span><span class=\"hljs-string\">\": \"</span><span class=\"hljs-keyword\">cross</span>-env <span class=\"hljs-keyword\">ANALYZE</span>=<span class=\"hljs-literal\">true</span> <span class=\"hljs-keyword\">next</span> <span class=\"hljs-keyword\">build</span><span class=\"hljs-string\">\",\n\"</span><span class=\"hljs-keyword\">analyze</span>:<span class=\"hljs-keyword\">server</span><span class=\"hljs-string\">\": \"</span><span class=\"hljs-keyword\">cross</span>-env BUNDLE_ANALYZE=<span class=\"hljs-keyword\">server</span> <span class=\"hljs-keyword\">next</span> <span class=\"hljs-keyword\">build</span><span class=\"hljs-string\">\",\n\"</span><span class=\"hljs-keyword\">analyze</span>:browser<span class=\"hljs-string\">\": \"</span><span class=\"hljs-keyword\">cross</span>-env BUNDLE_ANALYZE=browser <span class=\"hljs-keyword\">next</span> <span class=\"hljs-keyword\">build</span>\n</code></pre><p>现在的 next.config.js 所有配置</p>\n<pre><code><span class=\"hljs-keyword\">const</span> fetch = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"isomorphic-unfetch\"</span>);\n<span class=\"hljs-keyword\">const</span> withBundleAnalyzer = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"@zeit/next-bundle-analyzer\"</span>);\n<span class=\"hljs-keyword\">const</span> withLess = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"@zeit/next-less\"</span>);\n<span class=\"hljs-keyword\">const</span> FilterWarningsPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"webpack-filter-warnings-plugin\"</span>);\n\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">require</span> !== <span class=\"hljs-string\">\"undefined\"</span>) {\n  <span class=\"hljs-built_in\">require</span>.extensions[<span class=\"hljs-string\">\".less\"</span>] = <span class=\"hljs-function\"><span class=\"hljs-params\">file</span> =&gt;</span> {};\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">HACK_removeMinimizeOptionFromCssLoaders</span>(<span class=\"hljs-params\">config</span>) </span>{\n  config.module.rules.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">rule</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(rule.use)) {\n      rule.use.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">if</span> (u.loader === <span class=\"hljs-string\">\"css-loader\"</span> &amp;&amp; u.options) {\n          <span class=\"hljs-keyword\">delete</span> u.options.minimize;\n        }\n      });\n    }\n  });\n}\n\n<span class=\"hljs-built_in\">module</span>.exports = withBundleAnalyzer(\n  withLess({\n    <span class=\"hljs-attr\">analyzeServer</span>: [<span class=\"hljs-string\">\"server\"</span>, <span class=\"hljs-string\">\"both\"</span>].includes(process.env.BUNDLE_ANALYZE),\n    <span class=\"hljs-attr\">analyzeBrowser</span>: [<span class=\"hljs-string\">\"browser\"</span>, <span class=\"hljs-string\">\"both\"</span>].includes(process.env.BUNDLE_ANALYZE),\n    <span class=\"hljs-attr\">bundleAnalyzerConfig</span>: {\n      <span class=\"hljs-attr\">server</span>: {\n        <span class=\"hljs-attr\">analyzerMode</span>: <span class=\"hljs-string\">\"static\"</span>,\n        <span class=\"hljs-attr\">reportFilename</span>: <span class=\"hljs-string\">\"../bundles/server.html\"</span>\n      },\n      <span class=\"hljs-attr\">browser</span>: {\n        <span class=\"hljs-attr\">analyzerMode</span>: <span class=\"hljs-string\">\"static\"</span>,\n        <span class=\"hljs-attr\">reportFilename</span>: <span class=\"hljs-string\">\"../bundles/client.html\"</span>\n      }\n    },\n    <span class=\"hljs-attr\">exportPathMap</span>: <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-keyword\">const</span> paths = {\n        <span class=\"hljs-string\">\"/\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/\"</span> },\n        <span class=\"hljs-string\">\"/books\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/books\"</span> },\n        <span class=\"hljs-string\">\"/article\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/article\"</span> },\n        <span class=\"hljs-string\">\"/write\"</span>: { <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/write\"</span> }\n      };\n\n      <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">\"https://api.tvmaze.com/search/shows?q=batman\"</span>);\n      <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> res.json();\n      <span class=\"hljs-keyword\">const</span> shows = data.map(<span class=\"hljs-function\"><span class=\"hljs-params\">entry</span> =&gt;</span> entry.show);\n\n      shows.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">show</span> =&gt;</span> {\n        paths[<span class=\"hljs-string\">`/book/<span class=\"hljs-subst\">${show.id}</span>`</span>] = {\n          <span class=\"hljs-attr\">page</span>: <span class=\"hljs-string\">\"/book/[id]\"</span>,\n          <span class=\"hljs-attr\">query</span>: { <span class=\"hljs-attr\">id</span>: show.id }\n        };\n      });\n\n      <span class=\"hljs-keyword\">return</span> paths;\n    },\n    <span class=\"hljs-attr\">lessLoaderOptions</span>: {\n      <span class=\"hljs-attr\">javascriptEnabled</span>: <span class=\"hljs-literal\">true</span>\n    },\n    webpack(config) {\n      config.plugins.push(\n        <span class=\"hljs-keyword\">new</span> FilterWarningsPlugin({\n          <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/mini-css-extract-plugin[^]*Conflicting order between:/</span>\n        })\n      );\n      HACK_removeMinimizeOptionFromCssLoaders(config);\n      <span class=\"hljs-keyword\">return</span> config;\n    }\n  })\n);\n</code></pre><p>直接执行</p>\n<pre><code><span class=\"hljs-built_in\">npm</span> run analyze\n</code></pre><p>服务器文件分析<br><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.11.png\" alt=\"\"></p>\n<p>客户端文件分析<br><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.11.png\" alt=\"\"></p>\n<p>firebase 文件分析详情<br><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.29.png\" alt=\"\"></p>\n<p>可以看到当前 firebase 和 firebase/[id].js 存在对 firebase 模块的引用</p>\n<h4 id=\"-\">延迟加载</h4>\n<p>仅当用户尝试导航到其他页面时,我们才使用 firebase 模块.可以使用 Next.js 的动态导入功能轻松地做到这一点.</p>\n<p>修改 lib/load-db.js</p>\n<pre><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">loadDb</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> firebase = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'firebase/app'</span>);\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'firebase/database'</span>);\n\n  <span class=\"hljs-keyword\">try</span> {\n    firebase.initializeApp({\n      <span class=\"hljs-attr\">databaseURL</span>: <span class=\"hljs-string\">'https://hacker-news.firebaseio.com'</span>\n    });\n  } <span class=\"hljs-keyword\">catch</span> (err) {\n    <span class=\"hljs-comment\">// we skip the \"already exists\" message which is</span>\n    <span class=\"hljs-comment\">// not an actual error when we're hot-reloading</span>\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-regexp\">/already exists/</span>.test(err.message)) {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">'Firebase initialization error'</span>, err.stack);\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> firebase.database().ref(<span class=\"hljs-string\">'v0'</span>);\n}\n</code></pre><p>使用 import()函数加载 firebase 模块,用 await 来等待并解析模块.</p>\n<p>再次执行</p>\n<pre><code><span class=\"hljs-built_in\">npm</span> run analyze\n</code></pre><p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.33.png\" alt=\"\"></p>\n<p>firebase 模块具有自己的 bundle,<code>static/chunks/[a-random-string].js</code>.当您尝试导入 firebase/app 和 firebase/database 模块时,将加载此 bundle.</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.21.png\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.21.png\" alt=\"\"></p>\n<p>可以看到,firebse 和 firebase/[id].js 文件缩小了不少</p>\n<h4 id=\"-\">进行测试</h4>\n<p>由于需要更真实的测试在线上的表现,我们需要重新构建.</p>\n<pre><code><span class=\"hljs-built_in\">npm</span> run build\n<span class=\"hljs-built_in\">npm</span> run start\n</code></pre><p>然后输入 localhost:8866 (与 dev 不一样),之后进入 firebase 页面在进入 firebase 详情页面.</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.29.11.png\" alt=\"\"></p>\n<p>实际上只会第一次浏览页面时加载,当 firebase 页面导入 firebase/app 和 firebase/database 模块,会加载 firebase 的 bundle.等再次进入的时候,改 bundle 已经加载过,就不会再次加载`</p>\n<p>如图,再次加载没有请求<br><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.33.20.png\" alt=\"\"></p>\n<blockquote>\n<p>延迟加载的模块减少了主要 JavaScript 包的大小,带来了更快的加载速度</p>\n</blockquote>\n<h2 id=\"-\">延迟加载组件</h2>\n<p>在一个组件里面同时使用 3 个 markdown 相关组件</p>\n<pre><code><span class=\"hljs-keyword\">import</span> Markdown <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-markdown\"</span>;\n<span class=\"hljs-keyword\">import</span> marked <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"marked\"</span>;\n<span class=\"hljs-keyword\">import</span> Highlight <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-highlight\"</span>;\n</code></pre><p>导致这个页面过于庞大</p>\n<p>执行<code>npm run analyze</code>看看 markdown/[id]大小</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%884.47.22.png\" alt=\"\"></p>\n<p>但是我们不需要在一开始就使用这些模块,只有需要加载 markdown 文本时才需要.因此,如果我们仅在使用时才加载,那将大大减少初始 bundle,有助于页面快地加载.</p>\n<h4 id=\"-hoc-\">使用 HOC 高阶组件抽离渲染</h4>\n<p>新建 lib/with-post.js</p>\n<pre><code><span class=\"hljs-keyword\">import</span> Layout <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"../components/MyLayout\"</span>;\n<span class=\"hljs-keyword\">import</span> dynamic <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/dynamic\"</span>;\n<span class=\"hljs-keyword\">import</span> marked <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"marked\"</span>;\n\n<span class=\"hljs-keyword\">const</span> Highlight = dynamic(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">\"react-highlight\"</span>));\n\nmarked &amp;&amp;\n  marked.setOptions({\n    <span class=\"hljs-attr\">gfm</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">tables</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">breaks</span>: <span class=\"hljs-literal\">true</span>\n  });\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">WithPost</span>(<span class=\"hljs-params\">InnerComponent, options</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(props) {\n      <span class=\"hljs-keyword\">super</span>(props);\n      <span class=\"hljs-keyword\">this</span>.renderMarkdown = <span class=\"hljs-keyword\">this</span>.renderMarkdown.bind(<span class=\"hljs-keyword\">this</span>);\n    }\n\n    renderMarkdown(id) {\n      <span class=\"hljs-comment\">// If a code snippet contains in the markdown content</span>\n      <span class=\"hljs-comment\">// then use Highlight component</span>\n      <span class=\"hljs-keyword\">if</span> (id === <span class=\"hljs-number\">1</span> || id === <span class=\"hljs-string\">\"1\"</span>) {\n        <span class=\"hljs-keyword\">return</span> (\n          <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Layout</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>{options.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>当前id=&gt;{id}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"markdown\"</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Highlight</span> <span class=\"hljs-attr\">innerHTML</span>&gt;</span>{marked(options.content)}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Highlight</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Layout</span>&gt;</span></span>\n        );\n      }\n\n      <span class=\"hljs-comment\">// If not, simply render the generated HTML from markdown</span>\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Layout</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>{options.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>当前id=&gt;{id}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"markdown\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">dangerouslySetInnerHTML</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">__html:</span> <span class=\"hljs-attr\">marked</span>(<span class=\"hljs-attr\">options.content</span>) }} /&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Layout</span>&gt;</span>\n      );\n    }\n\n    render() {\n      return <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">InnerComponent</span> <span class=\"hljs-attr\">renderMarkdown</span>=<span class=\"hljs-string\">{this.renderMarkdown}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">InnerComponent</span>&gt;</span>;\n    }\n  };\n}\n\nexport default WithPost;</span>\n</code></pre><p>修改 marked/[id].js</p>\n<pre><code><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> withPost <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"../../lib/with-post\"</span>;\n<span class=\"hljs-keyword\">import</span> { withRouter } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/router\"</span>;\n\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"Deploy apps with ZEIT now\"</span>,\n  <span class=\"hljs-attr\">content</span>: <span class=\"hljs-string\">`\n          Deploying apps to ZEIT now is pretty easy.\n          Simply run the following command from your app root:\n          ~~~bash\n          npm i -g now # one time command\n          now\n          ~~~\n        `</span>\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Post</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{this.props.renderMarkdown(this.props.router.query.id)}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  }\n}\n\nPost = withRouter(Post);\nPost = withPost(Post, data);\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Post;\n</code></pre><p>现在需要使用 Next.js 中的动态导入将 react-highlight 组件转换为动态组件.最终实现这些组件仅在将要在页面中呈现时才加载.可以使用该 next/dynamic 来创建动态组件.</p>\n<h4 id=\"-\">动态组件</h4>\n<pre><code><span class=\"hljs-regexp\">//im</span>port Highlight <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-highlight'</span>\n<span class=\"hljs-keyword\">import</span> dynamic <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/dynamic'</span>;\n\nconst Highlight = dynamic(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'react-highlight'</span>));\n</code></pre><p>访问 localhost:6688,可以在 network 中找到单次 Highlight 的 bundle 引入</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.11.16.png\" alt=\"\"></p>\n<h4 id=\"-\">仅在需要时加载</h4>\n<pre><code><span class=\"hljs-keyword\">if</span> (id === <span class=\"hljs-number\">1</span> || id === <span class=\"hljs-string\">\"1\"</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Layout</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>{options.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>当前id=&gt;{id}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"markdown\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Highlight</span> <span class=\"hljs-attr\">innerHTML</span>&gt;</span>{marked(options.content)}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Highlight</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Layout</span>&gt;</span></span>\n  );\n}\n</code></pre><p>当前判断 id 是否为 1,如果是就加载 Highlight,否则就正常插入 html</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.58.17.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.58.17.png\" alt=\"\"></p>\n<p>使用动态组件后,就会将组件单独实现一个 bundle,加载时候直接加载这一个 bundle 就行了</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%889.40.51.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%889.40.45.png\" alt=\"\"></p>\n<p>效果也是实现了 javascript 主文件的精简,同时所以 marked/[id].js 的大小,能够根据实际来判断是否加载一大段可能不需要的代码.</p>\n<p>为了模拟真实的服务器渲染效果,需要重新构建</p>\n<pre><code><span class=\"hljs-built_in\">npm</span> run build\n<span class=\"hljs-built_in\">npm</span> run start\n</code></pre><p>上图中可以看到,highlight 的 bundle 名称是 16.[chunkname].js</p>\n<p>输入<a href=\"http://localhost:8866/marked/1,可以在head里面发现`\">http://localhost:8866/marked/1,可以在head里面发现`</a><link rel=\"preload\" href=\"/_next/static/chunks/commons.972eca8099a2576b25d9.js\" as=\"script\">`的存在.之后再切换为其它的 id,这一个 js 文件就没有在 head 中引入</p>\n<h2 id=\"-awp-\">创建 awp 页面</h2>\n<p>新建 pages/awp.js</p>\n<pre><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> config = { <span class=\"hljs-attr\">amp</span>: <span class=\"hljs-literal\">true</span> };\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Awp</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Welcome to the AMP only Index page!!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n}\n</code></pre><p><a href=\"https://imququ.com/post/amp-project.html\">AMP,来自 Google 的移动页面优化方案</a></p>\n<p>通过添加 amp: &#39;hybrid&#39;以下内容来创建混合 AMP 页面</p>\n<pre><code><span class=\"hljs-keyword\">import</span> { useAmp } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/amp'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> config = { <span class=\"hljs-attr\">amp</span>: <span class=\"hljs-string\">'hybrid'</span> };\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Awp</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> isAmp = useAmp();\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Welcome to the {isAmp ? 'AMP' : 'normal'} version of the Index page!!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n}\n</code></pre><h2 id=\"-\">自动静态优化</h2>\n<p><a href=\"https://nextjs.org/docs#automatic-static-optimization\">自动静态优化</a></p>\n<p>如果没有阻塞数据要求,则 Next.js 会自动确定页面为静态页面（可以预呈现）.判断标准就是 getInitialProps 在页面中是否存在.</p>\n<p>如果 getInitialProps 存在,则 Next.js 不会静态优化页面.相反,Next.js 将使用其默认行为并按请求呈现页面(即服务器端呈现).</p>\n<p>如果 getInitialProps 不存在,则 Next.js 会通过将其预呈现为静态 HTML 来自动静态优化您的页面.在预渲染期间,路由器的 query 对象将为空,因为 query 在此阶段我们没有信息要提供.query 水合后,将在客户端填充任何值.</p>\n<p>此功能允许 Next.js 发出包含服务器渲染页面和静态生成页面的混合应用程序.这样可以确保 Next.js 始终默认发出快速的应用程序.</p>\n<blockquote>\n<p>静态生成的页面仍然是反应性的：Next.js 将对您的应用程序客户端进行水化处理,使其具有完全的交互性.</p>\n</blockquote>\n<p>优点是优化的页面不需要服务器端计算,并且可以立即从 CDN 位置流式传输到最终用户.为用户带来超快的加载体验.</p>\n<ul>\n<li>在大多数情况下,你并不需要一个自定义的服务器,所以尝试添加 target: &#39;serverless&#39;</li>\n<li>getInitialProps 是页面是否静态的主要决定因素,如果不需要 SSR,请不要添加到页面</li>\n<li>并非所有动态数据都必须具有 SSR,例如,如果它在登录后,或者您不需要 SEO,那么在这种情况下,最好在外部进行获取 getInitialProps 使用静态 HTML 加载速度</li>\n</ul>\n"
}
