{"markdown":"## 导出 html 并开启服务\n\n我们将 pages 下页面导出为静态 HTML 页面.首先,next.config.js 在应用程序的根目录中创建一个名为的文件,并添加以下内容\n\n```\nexportPathMap: async function() {\n    return {\n        \"/\": { page: \"/\" },\n        \"/books\": { page: \"/books\" },\n        \"/article\": { page: \"/article\" },\n        \"/write\": { page: \"/write\" }\n    };\n},\n```\n\n然后打开 package.json 并添加 scripts 为以下内容：\n\n```\n  \"build\": \"next build\",\n  \"export\": \"next export\"\n```\n\n现在,您可以 out 在项目内部的目录中看到导出的 HTML 内容.\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%881.56.14.png)\n\n现在需要在本地开启一个静态服务器,进行测试\n\n```\nnpm install -g serve\n\ncd out\n\nserve -p 8866\n```\n\n> serve 是一个非常简单的静态 Web 服务器\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%881.59.25.png)\n\n## 导出其他页面\n\n将以下内容添加到 next.config.js 文件中：\n\n```\n  exportPathMap: async function() {\n    const paths = {\n      \"/\": { page: \"/\" },\n      \"/books\": { page: \"/books\" },\n      \"/article\": { page: \"/article\" },\n      \"/write\": { page: \"/write\" }\n    };\n\n    const res = await fetch(\"https://api.tvmaze.com/search/shows?q=batman\");\n    const data = await res.json();\n    const shows = data.map(entry => entry.show);\n\n    shows.forEach(show => {\n      paths[`/book/${show.id}`] = {\n        page: \"/book/[id]\",\n        query: { id: show.id }\n      };\n    });\n\n    return paths;\n  },\n```\n\n为了渲染详情页面,我们首先获取数据列表.然后,我们循环获取 id,并为其添加新路径并进行查询.\n\n关闭本地服务器并在次执行\n\n```\nnpm run export\n\ncd out\n\nserve -p 8080\n```\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%882.14.31.png)\n\n> 运行 next export 命令时,Next.js 不会构建应用程序.页面/book/[id]已经存在于构建中,因此无需再次构建整个应用程序.但是,如果我们对应用程序进行了任何更改,则需要再次构建应用程序以获取这些更改,就是在执行一个 npm run build\n\n## 添加 typescript\n\n```\nnpm install --save-dev typescript @types/react @types/node @types/react-dom\n```\n\n将 index.js 更改为 index.tsx\n\n生成的 tsconfig.json\n\n```\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"target\": \"es5\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\"\n  },\n  \"exclude\": [\"node_modules\"],\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\"]\n}\n```\n\nindex.tsx 页面提示缺少类型,因为我们没有告诉 TypeScript 它是 Next.js 页面,在 strict 模式下不允许隐式 any 类型.\n\n```\nimport { NextPage } from 'next';\n\nconst Home: NextPage<{ userAgent: string }> = ({ userAgent }) => (\n  <h1>Hello world! - user agent: {userAgent}</h1>\n);\n\nHome.getInitialProps = async ({ req }) => {\n  const userAgent = req ? req.headers['user-agent'] || '' : navigator.userAgent;\n  return { userAgent };\n};\n\nexport default Home;\n```\n\n## 懒加载模块\n\n#### 创建 firebase 页面\n\n整体项目代码 [官方案例](https://github.com/zeit/next-learn-demo/tree/master/E2-lazy-loading-modules)\n\n#### 添加 analyzer\n\n安装依赖包\n\n```\nnpm install firebase @zeit/next-bundle-analyzer cross-env --save\n```\n\n然后打开 package.json 并添加 scripts 为以下内容：\n\n```\n\"analyze\": \"cross-env ANALYZE=true next build\",\n\"analyze:server\": \"cross-env BUNDLE_ANALYZE=server next build\",\n\"analyze:browser\": \"cross-env BUNDLE_ANALYZE=browser next build\n```\n\n现在的 next.config.js 所有配置\n\n```\nconst fetch = require(\"isomorphic-unfetch\");\nconst withBundleAnalyzer = require(\"@zeit/next-bundle-analyzer\");\nconst withLess = require(\"@zeit/next-less\");\nconst FilterWarningsPlugin = require(\"webpack-filter-warnings-plugin\");\n\nif (typeof require !== \"undefined\") {\n  require.extensions[\".less\"] = file => {};\n}\n\nfunction HACK_removeMinimizeOptionFromCssLoaders(config) {\n  config.module.rules.forEach(rule => {\n    if (Array.isArray(rule.use)) {\n      rule.use.forEach(u => {\n        if (u.loader === \"css-loader\" && u.options) {\n          delete u.options.minimize;\n        }\n      });\n    }\n  });\n}\n\nmodule.exports = withBundleAnalyzer(\n  withLess({\n    analyzeServer: [\"server\", \"both\"].includes(process.env.BUNDLE_ANALYZE),\n    analyzeBrowser: [\"browser\", \"both\"].includes(process.env.BUNDLE_ANALYZE),\n    bundleAnalyzerConfig: {\n      server: {\n        analyzerMode: \"static\",\n        reportFilename: \"../bundles/server.html\"\n      },\n      browser: {\n        analyzerMode: \"static\",\n        reportFilename: \"../bundles/client.html\"\n      }\n    },\n    exportPathMap: async function() {\n      const paths = {\n        \"/\": { page: \"/\" },\n        \"/books\": { page: \"/books\" },\n        \"/article\": { page: \"/article\" },\n        \"/write\": { page: \"/write\" }\n      };\n\n      const res = await fetch(\"https://api.tvmaze.com/search/shows?q=batman\");\n      const data = await res.json();\n      const shows = data.map(entry => entry.show);\n\n      shows.forEach(show => {\n        paths[`/book/${show.id}`] = {\n          page: \"/book/[id]\",\n          query: { id: show.id }\n        };\n      });\n\n      return paths;\n    },\n    lessLoaderOptions: {\n      javascriptEnabled: true\n    },\n    webpack(config) {\n      config.plugins.push(\n        new FilterWarningsPlugin({\n          exclude: /mini-css-extract-plugin[^]*Conflicting order between:/\n        })\n      );\n      HACK_removeMinimizeOptionFromCssLoaders(config);\n      return config;\n    }\n  })\n);\n\n```\n\n直接执行\n\n```\nnpm run analyze\n```\n\n服务器文件分析\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.11.png)\n\n客户端文件分析\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.11.png)\n\nfirebase 文件分析详情\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.29.png)\n\n可以看到当前 firebase 和 firebase/[id].js 存在对 firebase 模块的引用\n\n#### 延迟加载\n\n仅当用户尝试导航到其他页面时,我们才使用 firebase 模块.可以使用 Next.js 的动态导入功能轻松地做到这一点.\n\n修改 lib/load-db.js\n\n```\nexport default async function loadDb() {\n  const firebase = await import('firebase/app');\n  await import('firebase/database');\n\n  try {\n    firebase.initializeApp({\n      databaseURL: 'https://hacker-news.firebaseio.com'\n    });\n  } catch (err) {\n    // we skip the \"already exists\" message which is\n    // not an actual error when we're hot-reloading\n    if (!/already exists/.test(err.message)) {\n      console.error('Firebase initialization error', err.stack);\n    }\n  }\n\n  return firebase.database().ref('v0');\n}\n```\n\n使用 import()函数加载 firebase 模块,用 await 来等待并解析模块.\n\n再次执行\n\n```\nnpm run analyze\n```\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.33.png)\n\nfirebase 模块具有自己的 bundle,`static/chunks/[a-random-string].js`.当您尝试导入 firebase/app 和 firebase/database 模块时,将加载此 bundle.\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.21.png)\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.21.png)\n\n可以看到,firebse 和 firebase/[id].js 文件缩小了不少\n\n#### 进行测试\n\n由于需要更真实的测试在线上的表现,我们需要重新构建.\n\n```\nnpm run build\nnpm run start\n```\n\n然后输入 localhost:8866 (与 dev 不一样),之后进入 firebase 页面在进入 firebase 详情页面.\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.29.11.png)\n\n实际上只会第一次浏览页面时加载,当 firebase 页面导入 firebase/app 和 firebase/database 模块,会加载 firebase 的 bundle.等再次进入的时候,改 bundle 已经加载过,就不会再次加载`\n\n如图,再次加载没有请求\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.33.20.png)\n\n> 延迟加载的模块减少了主要 JavaScript 包的大小,带来了更快的加载速度\n\n## 延迟加载组件\n\n在一个组件里面同时使用 3 个 markdown 相关组件\n\n```\nimport Markdown from \"react-markdown\";\nimport marked from \"marked\";\nimport Highlight from \"react-highlight\";\n```\n\n导致这个页面过于庞大\n\n执行`npm run analyze`看看 markdown/[id]大小\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%884.47.22.png)\n\n但是我们不需要在一开始就使用这些模块,只有需要加载 markdown 文本时才需要.因此,如果我们仅在使用时才加载,那将大大减少初始 bundle,有助于页面快地加载.\n\n#### 使用 HOC 高阶组件抽离渲染\n\n新建 lib/with-post.js\n\n```\nimport Layout from \"../components/MyLayout\";\nimport dynamic from \"next/dynamic\";\nimport marked from \"marked\";\n\nconst Highlight = dynamic(() => import(\"react-highlight\"));\n\nmarked &&\n  marked.setOptions({\n    gfm: true,\n    tables: true,\n    breaks: true\n  });\n\nfunction WithPost(InnerComponent, options) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.renderMarkdown = this.renderMarkdown.bind(this);\n    }\n\n    renderMarkdown(id) {\n      // If a code snippet contains in the markdown content\n      // then use Highlight component\n      if (id === 1 || id === \"1\") {\n        return (\n          <Layout>\n            <h1>{options.title}</h1>\n            <h3>当前id=>{id}</h3>\n            <div className=\"markdown\">\n              <Highlight innerHTML>{marked(options.content)}</Highlight>\n            </div>\n          </Layout>\n        );\n      }\n\n      // If not, simply render the generated HTML from markdown\n      return (\n        <Layout>\n          <h1>{options.title}</h1>\n          <h3>当前id=>{id}</h3>\n          <div className=\"markdown\">\n            <div dangerouslySetInnerHTML={{ __html: marked(options.content) }} />\n          </div>\n        </Layout>\n      );\n    }\n\n    render() {\n      return <InnerComponent renderMarkdown={this.renderMarkdown}></InnerComponent>;\n    }\n  };\n}\n\nexport default WithPost;\n\n```\n\n修改 marked/[id].js\n\n```\nimport React, { Component } from \"react\";\nimport withPost from \"../../lib/with-post\";\nimport { withRouter } from \"next/router\";\n\nconst data = {\n  title: \"Deploy apps with ZEIT now\",\n  content: `\n          Deploying apps to ZEIT now is pretty easy.\n          Simply run the following command from your app root:\n          ~~~bash\n          npm i -g now # one time command\n          now\n          ~~~\n        `\n};\n\nclass Post extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return <div>{this.props.renderMarkdown(this.props.router.query.id)}</div>;\n  }\n}\n\nPost = withRouter(Post);\nPost = withPost(Post, data);\nexport default Post;\n```\n\n现在需要使用 Next.js 中的动态导入将 react-highlight 组件转换为动态组件.最终实现这些组件仅在将要在页面中呈现时才加载.可以使用该 next/dynamic 来创建动态组件.\n\n#### 动态组件\n\n```\n//import Highlight from 'react-highlight'\nimport dynamic from 'next/dynamic';\n\nconst Highlight = dynamic(() => import('react-highlight'));\n```\n\n访问 localhost:6688,可以在 network 中找到单次 Highlight 的 bundle 引入\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.11.16.png)\n\n#### 仅在需要时加载\n\n```\nif (id === 1 || id === \"1\") {\n  return (\n    <Layout>\n      <h1>{options.title}</h1>\n      <h3>当前id=>{id}</h3>\n      <div className=\"markdown\">\n        <Highlight innerHTML>{marked(options.content)}</Highlight>\n      </div>\n    </Layout>\n  );\n}\n```\n\n当前判断 id 是否为 1,如果是就加载 Highlight,否则就正常插入 html\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.58.17.png)\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.58.17.png)\n\n使用动态组件后,就会将组件单独实现一个 bundle,加载时候直接加载这一个 bundle 就行了\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%889.40.51.png)\n\n![](https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%889.40.45.png)\n\n效果也是实现了 javascript 主文件的精简,同时所以 marked/[id].js 的大小,能够根据实际来判断是否加载一大段可能不需要的代码.\n\n为了模拟真实的服务器渲染效果,需要重新构建\n\n```\nnpm run build\nnpm run start\n```\n\n上图中可以看到,highlight 的 bundle 名称是 16.[chunkname].js\n\n输入http://localhost:8866/marked/1,可以在head里面发现`<link rel=\"preload\" href=\"/_next/static/chunks/commons.972eca8099a2576b25d9.js\" as=\"script\">`的存在.之后再切换为其它的 id,这一个 js 文件就没有在 head 中引入\n\n## 创建 awp 页面\n\n新建 pages/awp.js\n\n```\nexport const config = { amp: true };\n\nexport default function Awp(props) {\n  return <p>Welcome to the AMP only Index page!!</p>;\n}\n```\n\n[AMP,来自 Google 的移动页面优化方案](https://imququ.com/post/amp-project.html)\n\n通过添加 amp: 'hybrid'以下内容来创建混合 AMP 页面\n\n```\nimport { useAmp } from 'next/amp';\n\nexport const config = { amp: 'hybrid' };\n\nexport default function Awp(props) {\n  const isAmp = useAmp();\n  return <p>Welcome to the {isAmp ? 'AMP' : 'normal'} version of the Index page!!</p>;\n}\n```\n\n## 自动静态优化\n\n[自动静态优化](https://nextjs.org/docs#automatic-static-optimization)\n\n如果没有阻塞数据要求,则 Next.js 会自动确定页面为静态页面（可以预呈现）.判断标准就是 getInitialProps 在页面中是否存在.\n\n如果 getInitialProps 存在,则 Next.js 不会静态优化页面.相反,Next.js 将使用其默认行为并按请求呈现页面(即服务器端呈现).\n\n如果 getInitialProps 不存在,则 Next.js 会通过将其预呈现为静态 HTML 来自动静态优化您的页面.在预渲染期间,路由器的 query 对象将为空,因为 query 在此阶段我们没有信息要提供.query 水合后,将在客户端填充任何值.\n\n此功能允许 Next.js 发出包含服务器渲染页面和静态生成页面的混合应用程序.这样可以确保 Next.js 始终默认发出快速的应用程序.\n\n> 静态生成的页面仍然是反应性的：Next.js 将对您的应用程序客户端进行水化处理,使其具有完全的交互性.\n\n优点是优化的页面不需要服务器端计算,并且可以立即从 CDN 位置流式传输到最终用户.为用户带来超快的加载体验.\n\n- 在大多数情况下,你并不需要一个自定义的服务器,所以尝试添加 target: 'serverless'\n- getInitialProps 是页面是否静态的主要决定因素,如果不需要 SSR,请不要添加到页面\n- 并非所有动态数据都必须具有 SSR,例如,如果它在登录后,或者您不需要 SEO,那么在这种情况下,最好在外部进行获取 getInitialProps 使用静态 HTML 加载速度","html":"<h2 id=\"导出-html-并开启服务\">导出 html 并开启服务</h2>\n<p>我们将 pages 下页面导出为静态 HTML 页面.首先,next.config.js 在应用程序的根目录中创建一个名为的文件,并添加以下内容</p>\n<pre><code>exportPathMap: async function() {\n    return {\n        &quot;/&quot;: { page: &quot;/&quot; },\n        &quot;/books&quot;: { page: &quot;/books&quot; },\n        &quot;/article&quot;: { page: &quot;/article&quot; },\n        &quot;/write&quot;: { page: &quot;/write&quot; }\n    };\n},</code></pre><p>然后打开 package.json 并添加 scripts 为以下内容：</p>\n<pre><code>  &quot;build&quot;: &quot;next build&quot;,\n  &quot;export&quot;: &quot;next export&quot;</code></pre><p>现在,您可以 out 在项目内部的目录中看到导出的 HTML 内容.</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%881.56.14.png\" alt=\"\"></p>\n<p>现在需要在本地开启一个静态服务器,进行测试</p>\n<pre><code>npm install -g serve\n\ncd out\n\nserve -p 8866</code></pre><blockquote>\n<p>serve 是一个非常简单的静态 Web 服务器</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%881.59.25.png\" alt=\"\"></p>\n<h2 id=\"导出其他页面\">导出其他页面</h2>\n<p>将以下内容添加到 next.config.js 文件中：</p>\n<pre><code>  exportPathMap: async function() {\n    const paths = {\n      &quot;/&quot;: { page: &quot;/&quot; },\n      &quot;/books&quot;: { page: &quot;/books&quot; },\n      &quot;/article&quot;: { page: &quot;/article&quot; },\n      &quot;/write&quot;: { page: &quot;/write&quot; }\n    };\n\n    const res = await fetch(&quot;https://api.tvmaze.com/search/shows?q=batman&quot;);\n    const data = await res.json();\n    const shows = data.map(entry =&gt; entry.show);\n\n    shows.forEach(show =&gt; {\n      paths[`/book/${show.id}`] = {\n        page: &quot;/book/[id]&quot;,\n        query: { id: show.id }\n      };\n    });\n\n    return paths;\n  },</code></pre><p>为了渲染详情页面,我们首先获取数据列表.然后,我们循环获取 id,并为其添加新路径并进行查询.</p>\n<p>关闭本地服务器并在次执行</p>\n<pre><code>npm run export\n\ncd out\n\nserve -p 8080</code></pre><p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%882.14.31.png\" alt=\"\"></p>\n<blockquote>\n<p>运行 next export 命令时,Next.js 不会构建应用程序.页面/book/[id]已经存在于构建中,因此无需再次构建整个应用程序.但是,如果我们对应用程序进行了任何更改,则需要再次构建应用程序以获取这些更改,就是在执行一个 npm run build</p>\n</blockquote>\n<h2 id=\"添加-typescript\">添加 typescript</h2>\n<pre><code>npm install --save-dev typescript @types/react @types/node @types/react-dom</code></pre><p>将 index.js 更改为 index.tsx</p>\n<p>生成的 tsconfig.json</p>\n<pre><code>{\n  &quot;compilerOptions&quot;: {\n    &quot;experimentalDecorators&quot;: true,\n    &quot;target&quot;: &quot;es5&quot;,\n    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],\n    &quot;allowJs&quot;: true,\n    &quot;skipLibCheck&quot;: true,\n    &quot;strict&quot;: true,\n    &quot;forceConsistentCasingInFileNames&quot;: true,\n    &quot;noEmit&quot;: true,\n    &quot;esModuleInterop&quot;: true,\n    &quot;module&quot;: &quot;esnext&quot;,\n    &quot;moduleResolution&quot;: &quot;node&quot;,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;jsx&quot;: &quot;preserve&quot;\n  },\n  &quot;exclude&quot;: [&quot;node_modules&quot;],\n  &quot;include&quot;: [&quot;next-env.d.ts&quot;, &quot;**/*.ts&quot;, &quot;**/*.tsx&quot;]\n}</code></pre><p>index.tsx 页面提示缺少类型,因为我们没有告诉 TypeScript 它是 Next.js 页面,在 strict 模式下不允许隐式 any 类型.</p>\n<pre><code>import { NextPage } from &#39;next&#39;;\n\nconst Home: NextPage&lt;{ userAgent: string }&gt; = ({ userAgent }) =&gt; (\n  &lt;h1&gt;Hello world! - user agent: {userAgent}&lt;/h1&gt;\n);\n\nHome.getInitialProps = async ({ req }) =&gt; {\n  const userAgent = req ? req.headers[&#39;user-agent&#39;] || &#39;&#39; : navigator.userAgent;\n  return { userAgent };\n};\n\nexport default Home;</code></pre><h2 id=\"懒加载模块\">懒加载模块</h2>\n<h4 id=\"创建-firebase-页面\">创建 firebase 页面</h4>\n<p>整体项目代码 <a href=\"https://github.com/zeit/next-learn-demo/tree/master/E2-lazy-loading-modules\">官方案例</a></p>\n<h4 id=\"添加-analyzer\">添加 analyzer</h4>\n<p>安装依赖包</p>\n<pre><code>npm install firebase @zeit/next-bundle-analyzer cross-env --save</code></pre><p>然后打开 package.json 并添加 scripts 为以下内容：</p>\n<pre><code>&quot;analyze&quot;: &quot;cross-env ANALYZE=true next build&quot;,\n&quot;analyze:server&quot;: &quot;cross-env BUNDLE_ANALYZE=server next build&quot;,\n&quot;analyze:browser&quot;: &quot;cross-env BUNDLE_ANALYZE=browser next build</code></pre><p>现在的 next.config.js 所有配置</p>\n<pre><code>const fetch = require(&quot;isomorphic-unfetch&quot;);\nconst withBundleAnalyzer = require(&quot;@zeit/next-bundle-analyzer&quot;);\nconst withLess = require(&quot;@zeit/next-less&quot;);\nconst FilterWarningsPlugin = require(&quot;webpack-filter-warnings-plugin&quot;);\n\nif (typeof require !== &quot;undefined&quot;) {\n  require.extensions[&quot;.less&quot;] = file =&gt; {};\n}\n\nfunction HACK_removeMinimizeOptionFromCssLoaders(config) {\n  config.module.rules.forEach(rule =&gt; {\n    if (Array.isArray(rule.use)) {\n      rule.use.forEach(u =&gt; {\n        if (u.loader === &quot;css-loader&quot; &amp;&amp; u.options) {\n          delete u.options.minimize;\n        }\n      });\n    }\n  });\n}\n\nmodule.exports = withBundleAnalyzer(\n  withLess({\n    analyzeServer: [&quot;server&quot;, &quot;both&quot;].includes(process.env.BUNDLE_ANALYZE),\n    analyzeBrowser: [&quot;browser&quot;, &quot;both&quot;].includes(process.env.BUNDLE_ANALYZE),\n    bundleAnalyzerConfig: {\n      server: {\n        analyzerMode: &quot;static&quot;,\n        reportFilename: &quot;../bundles/server.html&quot;\n      },\n      browser: {\n        analyzerMode: &quot;static&quot;,\n        reportFilename: &quot;../bundles/client.html&quot;\n      }\n    },\n    exportPathMap: async function() {\n      const paths = {\n        &quot;/&quot;: { page: &quot;/&quot; },\n        &quot;/books&quot;: { page: &quot;/books&quot; },\n        &quot;/article&quot;: { page: &quot;/article&quot; },\n        &quot;/write&quot;: { page: &quot;/write&quot; }\n      };\n\n      const res = await fetch(&quot;https://api.tvmaze.com/search/shows?q=batman&quot;);\n      const data = await res.json();\n      const shows = data.map(entry =&gt; entry.show);\n\n      shows.forEach(show =&gt; {\n        paths[`/book/${show.id}`] = {\n          page: &quot;/book/[id]&quot;,\n          query: { id: show.id }\n        };\n      });\n\n      return paths;\n    },\n    lessLoaderOptions: {\n      javascriptEnabled: true\n    },\n    webpack(config) {\n      config.plugins.push(\n        new FilterWarningsPlugin({\n          exclude: /mini-css-extract-plugin[^]*Conflicting order between:/\n        })\n      );\n      HACK_removeMinimizeOptionFromCssLoaders(config);\n      return config;\n    }\n  })\n);\n</code></pre><p>直接执行</p>\n<pre><code>npm run analyze</code></pre><p>服务器文件分析\n<img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.11.png\" alt=\"\"></p>\n<p>客户端文件分析\n<img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.11.png\" alt=\"\"></p>\n<p>firebase 文件分析详情\n<img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.12.29.png\" alt=\"\"></p>\n<p>可以看到当前 firebase 和 firebase/[id].js 存在对 firebase 模块的引用</p>\n<h4 id=\"延迟加载\">延迟加载</h4>\n<p>仅当用户尝试导航到其他页面时,我们才使用 firebase 模块.可以使用 Next.js 的动态导入功能轻松地做到这一点.</p>\n<p>修改 lib/load-db.js</p>\n<pre><code>export default async function loadDb() {\n  const firebase = await import(&#39;firebase/app&#39;);\n  await import(&#39;firebase/database&#39;);\n\n  try {\n    firebase.initializeApp({\n      databaseURL: &#39;https://hacker-news.firebaseio.com&#39;\n    });\n  } catch (err) {\n    // we skip the &quot;already exists&quot; message which is\n    // not an actual error when we&#39;re hot-reloading\n    if (!/already exists/.test(err.message)) {\n      console.error(&#39;Firebase initialization error&#39;, err.stack);\n    }\n  }\n\n  return firebase.database().ref(&#39;v0&#39;);\n}</code></pre><p>使用 import()函数加载 firebase 模块,用 await 来等待并解析模块.</p>\n<p>再次执行</p>\n<pre><code>npm run analyze</code></pre><p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.33.png\" alt=\"\"></p>\n<p>firebase 模块具有自己的 bundle,<code>static/chunks/[a-random-string].js</code>.当您尝试导入 firebase/app 和 firebase/database 模块时,将加载此 bundle.</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.21.png\" alt=\"\">\n<img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.22.21.png\" alt=\"\"></p>\n<p>可以看到,firebse 和 firebase/[id].js 文件缩小了不少</p>\n<h4 id=\"进行测试\">进行测试</h4>\n<p>由于需要更真实的测试在线上的表现,我们需要重新构建.</p>\n<pre><code>npm run build\nnpm run start</code></pre><p>然后输入 localhost:8866 (与 dev 不一样),之后进入 firebase 页面在进入 firebase 详情页面.</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.29.11.png\" alt=\"\"></p>\n<p>实际上只会第一次浏览页面时加载,当 firebase 页面导入 firebase/app 和 firebase/database 模块,会加载 firebase 的 bundle.等再次进入的时候,改 bundle 已经加载过,就不会再次加载`</p>\n<p>如图,再次加载没有请求\n<img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%883.33.20.png\" alt=\"\"></p>\n<blockquote>\n<p>延迟加载的模块减少了主要 JavaScript 包的大小,带来了更快的加载速度</p>\n</blockquote>\n<h2 id=\"延迟加载组件\">延迟加载组件</h2>\n<p>在一个组件里面同时使用 3 个 markdown 相关组件</p>\n<pre><code>import Markdown from &quot;react-markdown&quot;;\nimport marked from &quot;marked&quot;;\nimport Highlight from &quot;react-highlight&quot;;</code></pre><p>导致这个页面过于庞大</p>\n<p>执行<code>npm run analyze</code>看看 markdown/[id]大小</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%884.47.22.png\" alt=\"\"></p>\n<p>但是我们不需要在一开始就使用这些模块,只有需要加载 markdown 文本时才需要.因此,如果我们仅在使用时才加载,那将大大减少初始 bundle,有助于页面快地加载.</p>\n<h4 id=\"使用-hoc-高阶组件抽离渲染\">使用 HOC 高阶组件抽离渲染</h4>\n<p>新建 lib/with-post.js</p>\n<pre><code>import Layout from &quot;../components/MyLayout&quot;;\nimport dynamic from &quot;next/dynamic&quot;;\nimport marked from &quot;marked&quot;;\n\nconst Highlight = dynamic(() =&gt; import(&quot;react-highlight&quot;));\n\nmarked &amp;&amp;\n  marked.setOptions({\n    gfm: true,\n    tables: true,\n    breaks: true\n  });\n\nfunction WithPost(InnerComponent, options) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.renderMarkdown = this.renderMarkdown.bind(this);\n    }\n\n    renderMarkdown(id) {\n      // If a code snippet contains in the markdown content\n      // then use Highlight component\n      if (id === 1 || id === &quot;1&quot;) {\n        return (\n          &lt;Layout&gt;\n            &lt;h1&gt;{options.title}&lt;/h1&gt;\n            &lt;h3&gt;当前id=&gt;{id}&lt;/h3&gt;\n            &lt;div className=&quot;markdown&quot;&gt;\n              &lt;Highlight innerHTML&gt;{marked(options.content)}&lt;/Highlight&gt;\n            &lt;/div&gt;\n          &lt;/Layout&gt;\n        );\n      }\n\n      // If not, simply render the generated HTML from markdown\n      return (\n        &lt;Layout&gt;\n          &lt;h1&gt;{options.title}&lt;/h1&gt;\n          &lt;h3&gt;当前id=&gt;{id}&lt;/h3&gt;\n          &lt;div className=&quot;markdown&quot;&gt;\n            &lt;div dangerouslySetInnerHTML={{ __html: marked(options.content) }} /&gt;\n          &lt;/div&gt;\n        &lt;/Layout&gt;\n      );\n    }\n\n    render() {\n      return &lt;InnerComponent renderMarkdown={this.renderMarkdown}&gt;&lt;/InnerComponent&gt;;\n    }\n  };\n}\n\nexport default WithPost;\n</code></pre><p>修改 marked/[id].js</p>\n<pre><code>import React, { Component } from &quot;react&quot;;\nimport withPost from &quot;../../lib/with-post&quot;;\nimport { withRouter } from &quot;next/router&quot;;\n\nconst data = {\n  title: &quot;Deploy apps with ZEIT now&quot;,\n  content: `\n          Deploying apps to ZEIT now is pretty easy.\n          Simply run the following command from your app root:\n          ~~~bash\n          npm i -g now # one time command\n          now\n          ~~~\n        `\n};\n\nclass Post extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return &lt;div&gt;{this.props.renderMarkdown(this.props.router.query.id)}&lt;/div&gt;;\n  }\n}\n\nPost = withRouter(Post);\nPost = withPost(Post, data);\nexport default Post;</code></pre><p>现在需要使用 Next.js 中的动态导入将 react-highlight 组件转换为动态组件.最终实现这些组件仅在将要在页面中呈现时才加载.可以使用该 next/dynamic 来创建动态组件.</p>\n<h4 id=\"动态组件\">动态组件</h4>\n<pre><code>//import Highlight from &#39;react-highlight&#39;\nimport dynamic from &#39;next/dynamic&#39;;\n\nconst Highlight = dynamic(() =&gt; import(&#39;react-highlight&#39;));</code></pre><p>访问 localhost:6688,可以在 network 中找到单次 Highlight 的 bundle 引入</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.11.16.png\" alt=\"\"></p>\n<h4 id=\"仅在需要时加载\">仅在需要时加载</h4>\n<pre><code>if (id === 1 || id === &quot;1&quot;) {\n  return (\n    &lt;Layout&gt;\n      &lt;h1&gt;{options.title}&lt;/h1&gt;\n      &lt;h3&gt;当前id=&gt;{id}&lt;/h3&gt;\n      &lt;div className=&quot;markdown&quot;&gt;\n        &lt;Highlight innerHTML&gt;{marked(options.content)}&lt;/Highlight&gt;\n      &lt;/div&gt;\n    &lt;/Layout&gt;\n  );\n}</code></pre><p>当前判断 id 是否为 1,如果是就加载 Highlight,否则就正常插入 html</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.58.17.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%885.58.17.png\" alt=\"\"></p>\n<p>使用动态组件后,就会将组件单独实现一个 bundle,加载时候直接加载这一个 bundle 就行了</p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%889.40.51.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/easterCat/img-package/master/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-21%20%E4%B8%8B%E5%8D%889.40.45.png\" alt=\"\"></p>\n<p>效果也是实现了 javascript 主文件的精简,同时所以 marked/[id].js 的大小,能够根据实际来判断是否加载一大段可能不需要的代码.</p>\n<p>为了模拟真实的服务器渲染效果,需要重新构建</p>\n<pre><code>npm run build\nnpm run start</code></pre><p>上图中可以看到,highlight 的 bundle 名称是 16.[chunkname].js</p>\n<p>输入<a href=\"http://localhost:8866/marked/1,%E5%8F%AF%E4%BB%A5%E5%9C%A8head%E9%87%8C%E9%9D%A2%E5%8F%91%E7%8E%B0%60\">http://localhost:8866/marked/1,可以在head里面发现`</a><link rel=\"preload\" href=\"/_next/static/chunks/commons.972eca8099a2576b25d9.js\" as=\"script\">`的存在.之后再切换为其它的 id,这一个 js 文件就没有在 head 中引入</p>\n<h2 id=\"创建-awp-页面\">创建 awp 页面</h2>\n<p>新建 pages/awp.js</p>\n<pre><code>export const config = { amp: true };\n\nexport default function Awp(props) {\n  return &lt;p&gt;Welcome to the AMP only Index page!!&lt;/p&gt;;\n}</code></pre><p><a href=\"https://imququ.com/post/amp-project.html\">AMP,来自 Google 的移动页面优化方案</a></p>\n<p>通过添加 amp: &#39;hybrid&#39;以下内容来创建混合 AMP 页面</p>\n<pre><code>import { useAmp } from &#39;next/amp&#39;;\n\nexport const config = { amp: &#39;hybrid&#39; };\n\nexport default function Awp(props) {\n  const isAmp = useAmp();\n  return &lt;p&gt;Welcome to the {isAmp ? &#39;AMP&#39; : &#39;normal&#39;} version of the Index page!!&lt;/p&gt;;\n}</code></pre><h2 id=\"自动静态优化\">自动静态优化</h2>\n<p><a href=\"https://nextjs.org/docs#automatic-static-optimization\">自动静态优化</a></p>\n<p>如果没有阻塞数据要求,则 Next.js 会自动确定页面为静态页面（可以预呈现）.判断标准就是 getInitialProps 在页面中是否存在.</p>\n<p>如果 getInitialProps 存在,则 Next.js 不会静态优化页面.相反,Next.js 将使用其默认行为并按请求呈现页面(即服务器端呈现).</p>\n<p>如果 getInitialProps 不存在,则 Next.js 会通过将其预呈现为静态 HTML 来自动静态优化您的页面.在预渲染期间,路由器的 query 对象将为空,因为 query 在此阶段我们没有信息要提供.query 水合后,将在客户端填充任何值.</p>\n<p>此功能允许 Next.js 发出包含服务器渲染页面和静态生成页面的混合应用程序.这样可以确保 Next.js 始终默认发出快速的应用程序.</p>\n<blockquote>\n<p>静态生成的页面仍然是反应性的：Next.js 将对您的应用程序客户端进行水化处理,使其具有完全的交互性.</p>\n</blockquote>\n<p>优点是优化的页面不需要服务器端计算,并且可以立即从 CDN 位置流式传输到最终用户.为用户带来超快的加载体验.</p>\n<ul>\n<li>在大多数情况下,你并不需要一个自定义的服务器,所以尝试添加 target: &#39;serverless&#39;</li>\n<li>getInitialProps 是页面是否静态的主要决定因素,如果不需要 SSR,请不要添加到页面</li>\n<li>并非所有动态数据都必须具有 SSR,例如,如果它在登录后,或者您不需要 SEO,那么在这种情况下,最好在外部进行获取 getInitialProps 使用静态 HTML 加载速度</li>\n</ul>\n"}
