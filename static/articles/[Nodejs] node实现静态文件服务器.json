{
  "markdown": "## node 静态文件处理\n\n一般后端进行静态文件处理都是使用 Apache nginx 等静态 web 服务器,但是既然使用 node 了,就用 node 实现以下静态服务器吧.\n\n之前弄了不少充满艺术的数据,就弄个页面进行艺术欣赏吧\n\napp.js\n\n```\n    \"/\": (request, response) => {\n      response.writeHead(200, { \"content-type\": \"text/html;charset=utf-8\" });\n      let stream = fs.createReadStream(\n        path.join(__dirname, \"/views/index.html\")\n      );\n      stream.on(\"error\", function() {\n        response.writeHead(500, { \"content-type\": \"text/html;charset=utf-8\" });\n        response.end(\"<h1>500 Server Error</h1>\");\n      });\n      stream.pipe(response);\n    },\n```\n\nviews/index.html/index.js/index.css\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>时尚风范</title>\n    <link rel=\"stylesheet\" href=\"./index.css\" type=\"text/css\" />\n    <script src=\"./index.js\"></script>\n  </head>\n  <body>\n    <div class=\"img-list\">\n      <div class=\"header\">我是写真集</header>\n    </div>\n  </body>\n</html>\n```\n\n![01](https://github.com/easterCat/node-utils/blob/master/04.node%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/img/01.png?raw=true)\n但是打开之后什么都不能看,css 和 js 在控制台都是 404 显示.因为服务器没有写相应的代码去处理这些文件,所以接收到请求,服务器也是一脸茫然,不知道究竟要干什么.\n\n> 所有我们要对请求的资源做出相对应的回答,那怕是个 404\n\n添加 css 和 js 的支持\n\n```\n\"/index.css\": (request, response) => {\n      response.writeHead(200, { \"content-type\": \"text/css;chartset=utf-8\" });\n      let stream = fs.createReadStream(\n        path.join(__dirname, \"/views/index.css\")\n      );\n      stream.on(\"error\", function() {\n        response.writeHead(500, { \"content-type\": \"text/html;charset=utf-8\" });\n        response.end(\"<h1>500 Server Error</h1>\");\n      });\n      stream.pipe(response);\n    },\n    \"/index.js\": (request, response) => {\n      response.writeHead(200, {\n        \"content-type\": \"text/javasvript;chartset=utf-8\"\n      });\n      let stream = fs.createReadStream(\n        path.join(__dirname, \"/views/index.js\")\n      );\n      stream.on(\"error\", function() {\n        response.writeHead(500, { \"content-type\": \"text/html;charset=utf-8\" });\n        response.end(\"<h1>500 Server Error</h1>\");\n      });\n      stream.pipe(response);\n    },\n```\n\n这样就正常的加载和执行 css 和 js 了,但是代码灵活性不够,重复率太高.\n\n## 静态资源服务器\n\n#### 区分路由\n\n```\n...\nif (pathname !== \"/favicon.ico\") {\n  if (path.extname(pathname) === \"\") {\n    router(pathname)(request, response);\n  } else {\n    assets(pathname)(request, response);\n  }\n}\n...\n```\n\n添加静态资源处理\n\n```\nfunction assets(p) {\n  let ext = path.extname(p);\n  ext = ext ? ext.slice(1) : \"unknown\";\n  let contentType = getMime(ext);\n  contentType += \";charset=utf-8\";\n  let filePath;\n\n  if (/image/.test(contentType)) {\n    filePath = path.join(static_path, p);\n  } else {\n    filePath = path.join(public_path, p);\n  }\n\n  return async function(request, response) {\n    try {\n      let stats = await stat(filePath);\n      if (stats && stats.isFile()) {\n        readFile(response, filePath, contentType);\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  };\n}\n```\n\n#### 我们需要根据文件类型做相应处理\n\n对不同的文件进行不同的响应头处理\n\n```\nmodule.exports = {\n  getMime: function(ext) {\n    let mime = {\n      css: \"text/css\",\n      gif: \"image/gif\",\n      html: \"text/html\",\n      ico: \"image/x-icon\",\n      jpeg: \"image/jpeg\",\n      jpg: \"image/jpeg\",\n      js: \"text/javascript\",\n      json: \"application/json\",\n      pdf: \"application/pdf\",\n      png: \"image/png\",\n      svg: \"image/svg+xml\",\n      swf: \"application/x-shockwave-flash\",\n      tiff: \"image/tiff\",\n      txt: \"text/plain\",\n      wav: \"audio/x-wav\",\n      wma: \"audio/x-ms-wma\",\n      wmv: \"video/x-ms-wmv\",\n      xml: \"text/xml\"\n    };\n    return mime[ext] || \"text/plain\";\n  }\n};\n```\n\n#### 加载相应的静态文件\n\n```\nfunction readFile(response, filePath, contentType) {\n  response.writeHead(200, { \"content-type\": contentType });\n  let stream = fs.createReadStream(filePath);\n  stream.on(\"error\", function() {\n    response.writeHead(500, { \"content-type\": contentType });\n    response.end(\"<h1>500 Server Error</h1>\");\n  });\n  stream.pipe(response);\n}\n```\n\n#### index.js\n\n```\nwindow.onload = function() {\n  let path =\n    \"http://127.0.0.1:9527/mrw/%E5%B0%8F%E6%B2%AB%E7%90%B3%E3%80%8A%E8%8B%8F%E6%A2%85%E5%B2%9B%E6%97%85%E6%8B%8D%E5%86%99%E7%9C%9F%E3%80%8B%20[%E8%8A%B1%E3%81%AE%E9%A2%9CHuaYan]%20Vol.057%20%E5%86%99%E7%9C%9F%E9%9B%86/%E5%B0%8F%E6%B2%AB%E7%90%B3%E3%80%8A%E8%8B%8F%E6%A2%85%E5%B2%9B%E6%97%85%E6%8B%8D%E5%86%99%E7%9C%9F%E3%80%8B%20[%E8%8A%B1%E3%81%AE%E9%A2%9CHuaYan]%20Vol.057%20%E5%86%99%E7%9C%9F%E9%9B%86_image\";\n\n  let suffix = \".jpg\";\n  let content = document.createElement(\"div\");\n  let body = document.getElementsByTagName(\"body\")[0];\n  content.setAttribute(\"class\", \"content\");\n\n  for (let i = 0; i < 56; i++) {\n    let item = document.createElement(\"img\");\n    item.setAttribute(\"src\", `${path}${i}${suffix}`);\n    content.appendChild(item);\n  }\n  body.appendChild(content);\n};\n```\n\n![02](https://github.com/easterCat/node-utils/blob/master/04.node%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/img/02.png?raw=true)\n\n当然,正常的写真集不是这样做的,而是通过数据库存储硬盘路径存放地址,然后返回给前端 url+path 的形式,路径也不会这么长.这里只是处理静态文件.\n\n## Docs\n\n- [node 的 mime 模块](https://www.npmjs.com/package/mime)\n- [常见的 MIME 类型](https://blog.csdn.net/daily886/article/details/79068844)\n- [fs 模块 -- JavaScript 标准参考教程（alpha）](http://javascript.ruanyifeng.com/nodejs/fs.html#toc8)\n- [用原生 Node 实现一个静态 web 服务器](https://blog.csdn.net/weixin_37823121/article/details/82109562)\n\n  声明:仅供学习,不可用于商业用途",
  "html": "<h2 id=\"node-静态文件处理\">node 静态文件处理</h2>\n<p>一般后端进行静态文件处理都是使用 Apache nginx 等静态 web 服务器,但是既然使用 node 了,就用 node 实现以下静态服务器吧.</p>\n<p>之前弄了不少充满艺术的数据,就弄个页面进行艺术欣赏吧</p>\n<p>app.js</p>\n<pre><code>    &quot;/&quot;: (request, response) =&gt; {\n      response.writeHead(200, { &quot;content-type&quot;: &quot;text/html;charset=utf-8&quot; });\n      let stream = fs.createReadStream(\n        path.join(__dirname, &quot;/views/index.html&quot;)\n      );\n      stream.on(&quot;error&quot;, function() {\n        response.writeHead(500, { &quot;content-type&quot;: &quot;text/html;charset=utf-8&quot; });\n        response.end(&quot;&lt;h1&gt;500 Server Error&lt;/h1&gt;&quot;);\n      });\n      stream.pipe(response);\n    },</code></pre><p>views/index.html/index.js/index.css</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;时尚风范&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot; type=&quot;text/css&quot; /&gt;\n    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=&quot;img-list&quot;&gt;\n      &lt;div class=&quot;header&quot;&gt;我是写真集&lt;/header&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre><p><img src=\"https://github.com/easterCat/node-utils/blob/master/04.node%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/img/01.png?raw=true\" alt=\"01\">\n但是打开之后什么都不能看,css 和 js 在控制台都是 404 显示.因为服务器没有写相应的代码去处理这些文件,所以接收到请求,服务器也是一脸茫然,不知道究竟要干什么.</p>\n<blockquote>\n<p>所有我们要对请求的资源做出相对应的回答,那怕是个 404</p>\n</blockquote>\n<p>添加 css 和 js 的支持</p>\n<pre><code>&quot;/index.css&quot;: (request, response) =&gt; {\n      response.writeHead(200, { &quot;content-type&quot;: &quot;text/css;chartset=utf-8&quot; });\n      let stream = fs.createReadStream(\n        path.join(__dirname, &quot;/views/index.css&quot;)\n      );\n      stream.on(&quot;error&quot;, function() {\n        response.writeHead(500, { &quot;content-type&quot;: &quot;text/html;charset=utf-8&quot; });\n        response.end(&quot;&lt;h1&gt;500 Server Error&lt;/h1&gt;&quot;);\n      });\n      stream.pipe(response);\n    },\n    &quot;/index.js&quot;: (request, response) =&gt; {\n      response.writeHead(200, {\n        &quot;content-type&quot;: &quot;text/javasvript;chartset=utf-8&quot;\n      });\n      let stream = fs.createReadStream(\n        path.join(__dirname, &quot;/views/index.js&quot;)\n      );\n      stream.on(&quot;error&quot;, function() {\n        response.writeHead(500, { &quot;content-type&quot;: &quot;text/html;charset=utf-8&quot; });\n        response.end(&quot;&lt;h1&gt;500 Server Error&lt;/h1&gt;&quot;);\n      });\n      stream.pipe(response);\n    },</code></pre><p>这样就正常的加载和执行 css 和 js 了,但是代码灵活性不够,重复率太高.</p>\n<h2 id=\"静态资源服务器\">静态资源服务器</h2>\n<h4 id=\"区分路由\">区分路由</h4>\n<pre><code>...\nif (pathname !== &quot;/favicon.ico&quot;) {\n  if (path.extname(pathname) === &quot;&quot;) {\n    router(pathname)(request, response);\n  } else {\n    assets(pathname)(request, response);\n  }\n}\n...</code></pre><p>添加静态资源处理</p>\n<pre><code>function assets(p) {\n  let ext = path.extname(p);\n  ext = ext ? ext.slice(1) : &quot;unknown&quot;;\n  let contentType = getMime(ext);\n  contentType += &quot;;charset=utf-8&quot;;\n  let filePath;\n\n  if (/image/.test(contentType)) {\n    filePath = path.join(static_path, p);\n  } else {\n    filePath = path.join(public_path, p);\n  }\n\n  return async function(request, response) {\n    try {\n      let stats = await stat(filePath);\n      if (stats &amp;&amp; stats.isFile()) {\n        readFile(response, filePath, contentType);\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  };\n}</code></pre><h4 id=\"我们需要根据文件类型做相应处理\">我们需要根据文件类型做相应处理</h4>\n<p>对不同的文件进行不同的响应头处理</p>\n<pre><code>module.exports = {\n  getMime: function(ext) {\n    let mime = {\n      css: &quot;text/css&quot;,\n      gif: &quot;image/gif&quot;,\n      html: &quot;text/html&quot;,\n      ico: &quot;image/x-icon&quot;,\n      jpeg: &quot;image/jpeg&quot;,\n      jpg: &quot;image/jpeg&quot;,\n      js: &quot;text/javascript&quot;,\n      json: &quot;application/json&quot;,\n      pdf: &quot;application/pdf&quot;,\n      png: &quot;image/png&quot;,\n      svg: &quot;image/svg+xml&quot;,\n      swf: &quot;application/x-shockwave-flash&quot;,\n      tiff: &quot;image/tiff&quot;,\n      txt: &quot;text/plain&quot;,\n      wav: &quot;audio/x-wav&quot;,\n      wma: &quot;audio/x-ms-wma&quot;,\n      wmv: &quot;video/x-ms-wmv&quot;,\n      xml: &quot;text/xml&quot;\n    };\n    return mime[ext] || &quot;text/plain&quot;;\n  }\n};</code></pre><h4 id=\"加载相应的静态文件\">加载相应的静态文件</h4>\n<pre><code>function readFile(response, filePath, contentType) {\n  response.writeHead(200, { &quot;content-type&quot;: contentType });\n  let stream = fs.createReadStream(filePath);\n  stream.on(&quot;error&quot;, function() {\n    response.writeHead(500, { &quot;content-type&quot;: contentType });\n    response.end(&quot;&lt;h1&gt;500 Server Error&lt;/h1&gt;&quot;);\n  });\n  stream.pipe(response);\n}</code></pre><h4 id=\"indexjs\">index.js</h4>\n<pre><code>window.onload = function() {\n  let path =\n    &quot;http://127.0.0.1:9527/mrw/%E5%B0%8F%E6%B2%AB%E7%90%B3%E3%80%8A%E8%8B%8F%E6%A2%85%E5%B2%9B%E6%97%85%E6%8B%8D%E5%86%99%E7%9C%9F%E3%80%8B%20[%E8%8A%B1%E3%81%AE%E9%A2%9CHuaYan]%20Vol.057%20%E5%86%99%E7%9C%9F%E9%9B%86/%E5%B0%8F%E6%B2%AB%E7%90%B3%E3%80%8A%E8%8B%8F%E6%A2%85%E5%B2%9B%E6%97%85%E6%8B%8D%E5%86%99%E7%9C%9F%E3%80%8B%20[%E8%8A%B1%E3%81%AE%E9%A2%9CHuaYan]%20Vol.057%20%E5%86%99%E7%9C%9F%E9%9B%86_image&quot;;\n\n  let suffix = &quot;.jpg&quot;;\n  let content = document.createElement(&quot;div&quot;);\n  let body = document.getElementsByTagName(&quot;body&quot;)[0];\n  content.setAttribute(&quot;class&quot;, &quot;content&quot;);\n\n  for (let i = 0; i &lt; 56; i++) {\n    let item = document.createElement(&quot;img&quot;);\n    item.setAttribute(&quot;src&quot;, `${path}${i}${suffix}`);\n    content.appendChild(item);\n  }\n  body.appendChild(content);\n};</code></pre><p><img src=\"https://github.com/easterCat/node-utils/blob/master/04.node%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/img/02.png?raw=true\" alt=\"02\"></p>\n<p>当然,正常的写真集不是这样做的,而是通过数据库存储硬盘路径存放地址,然后返回给前端 url+path 的形式,路径也不会这么长.这里只是处理静态文件.</p>\n<h2 id=\"docs\">Docs</h2>\n<ul>\n<li><p><a href=\"https://www.npmjs.com/package/mime\">node 的 mime 模块</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/daily886/article/details/79068844\">常见的 MIME 类型</a></p>\n</li>\n<li><p><a href=\"http://javascript.ruanyifeng.com/nodejs/fs.html#toc8\">fs 模块 -- JavaScript 标准参考教程（alpha）</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/weixin_37823121/article/details/82109562\">用原生 Node 实现一个静态 web 服务器</a></p>\n<p>声明:仅供学习,不可用于商业用途</p>\n</li>\n</ul>\n"
}
